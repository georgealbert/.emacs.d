
* common setting
** 启动优化 [2019-05-18 周六 22:43:45]

doom-emacs介绍了它是如何做到启动速度这么快的 https://github.com/hlissner/doom-emacs/wiki/FAQ#how-is-dooms-startup-so-fast

Use lexical-binding everywhere. Add ;; -*- lexical-binding: t; -*- to the top of your elisp files. This can break code if you’ve written it to depend on dynamic variables, but I’ve written Doom not to.

[2019-05-18 周六 23:35:01] 好像没什么效果。
#+BEGIN_SRC emacs-lisp
;;; Albert.el -*- lexical-binding: t; -*-
#+END_SRC

[2019-05-18 周六 23:34:20] 学习anything的作者 https://github.com/manateelazycat/lazycat-emacs/blob/master/site-lisp/config/init.el

优化Emacs启动速度的方法论 https://manateelazycat.github.io/emacs/2019/05/12/emacs-optimize-startup-speed.html
*** garbage collector优化 [2019-05-20 周一 10:53:13]
[2019-05-18 周六 20:43:50] 从10s -> 5.5s左右，不知道效果能持续多久。
设置垃圾回收，在Windows下，emacs 25版本会频繁出发垃圾回收，所以需要设置。

[2019-05-18 周六 21:54:06] emacs 26.2启动时间15s，先注释掉吧。内存设置过大在长时间使用后gc会导致响应慢。
[2019-05-24 周五 09:12:45] 参考doom-emacs的init.el，代码放到在init.el里

** elpa

#+BEGIN_SRC emacs-lisp
(require 'package)

(add-to-list 'package-archives
  '("melpa" . "http://melpa.org/packages/") t)

;; (unless (assoc-default "melpa" package-archives)
;;   (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t))
;; (unless (assoc-default "org" package-archives)
;;   (add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/") t))

(package-initialize)
;(setq package-user-dir (concat dotfiles-dir "/elpa"))

(unless (package-installed-p 'use-package)
  (package-install 'use-package))

;; [2019-01-11 周五 23:23:40] always-ensure一打开就起不来了，可能网络不好
(setq use-package-always-ensure t)
(setq use-package-verbose t)
(require 'use-package)

(use-package auto-compile
  :config (auto-compile-on-load-mode))
(setq load-prefer-newer t)
#+end_src

代理配置
;(setq url-proxy-services
;   '(("no_proxy" . "^\\(localhost\\|10.*\\)")
;     ("http" . "134.80.3.27:8080")
;     ("https" . "134.80.3.27:8080")))

** HOME
默认目录设为 =HOME= 目录，不设的话默认是 /emacs安装目录/bin/ 。

#+BEGIN_SRC emacs-lisp
(setq default-directory "~/")
#+END_SRC

** Performace problem on windows

[2014-09-12 09:34:00] 就算这样有时候会很卡，xp下就好多了，怀疑和win7/域用户有关。
如果打开会看见很多QueryBasicInformation这样的调用.

#+BEGIN_SRC emacs-lisp
(if (eq system-type 'windows-nt)
    (setq w32-get-true-file-attributes nil))
#+END_SRC

** UTF-8编码
[2014-09-17 14:59:51]

文件名在emacs使用utf-8的默认编码的时候是乱码，win下指定编码为gbk。
#+BEGIN_SRC emacs-lisp
(prefer-coding-system 'utf-8)

(if (eq system-type 'windows-nt)
  (setq file-name-coding-system 'gbk))

;; for linux terminal
(if (eq system-type 'gnu/linux)
  (progn
    (setq locale-coding-system 'utf-8)
    (set-terminal-coding-system 'utf-8)
    (set-keyboard-coding-system 'utf-8)
    (set-selection-coding-system 'utf-8)))
#+END_SRC

** Backups
[2014-09-12 09:32:53]

This is one of the things people usually want to change right away. By default, 
Emacs saves backup files in the current directory. These are the files ending in ~ that are cluttering up your directory lists. 
The following code stashes them all in ~/.emacs.d/backups, where I can find them with C-x C-f (find-file) if I really need to.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backup")))

;; 自动存盘
(setq auto-save-mode t) 
#+END_SRC

Disk space is cheap. Save lots.
#+BEGIN_SRC emacs-lisp
(setq delete-old-versions -1)
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
#+END_SRC

** Diredplus - 不用了

[2014-09-11 10:47:57] 昨天刚开始用的，五颜六色的比较好看。

[2014-11-18 周二 10:54:56] 为什么在24.4上就不显示时间戳和权限了呢？

set =diredp-hide-details-initially-flag= to nil in 24.4 to display details, set
before dired+ loaded

也可以按 =(= 打开或关闭detail显示。

[2019-06-09 周日 22:15:45] 如果要用dired+的话，把 =:defer t= 注释掉。现在用vanilla dired就ok了。dired+在delete files的时候，显示不完全。而且在emacs启动时会加载一些package。
#+BEGIN_SRC lisp
(setq diredp-hide-details-initially-flag nil)
(use-package dired+
  :defer t)
#+END_SRC
** dired-k from doom-emacs [2019-06-10 Mon 11:09:35]

[2019-06-16 周日 00:02:50] 突然发现在dired里面 查找后 按 n，不是查询下一个。
因为默认在dired.el里面 n 是 binding为下一行。doom-emacs里面是什么样的?

#+BEGIN_SRC emacs-lisp
(use-package dired-k
  ;; :unless (featurep! +ranger)
  :defer t
  :hook (dired-initial-position . dired-k)
  :hook (dired-after-readin . dired-k-no-revert)
  :config
  (defun +dired*interrupt-process (orig-fn &rest args)
    "Fixes dired-k killing git processes too abruptly, leaving behind disruptive
     .git/index.lock files."
    (cl-letf (((symbol-function #'kill-process)
               (symbol-function #'interrupt-process)))
      (apply orig-fn args)))
  (advice-add #'dired-k--start-git-status :around #'+dired*interrupt-process)

  (defun +dired*dired-k-highlight (orig-fn &rest args)
    "Butt out if the requested directory is remote (i.e. through tramp)."
    (unless (file-remote-p default-directory)
      (apply orig-fn args)))
  (advice-add #'dired-k--highlight :around #'+dired*dired-k-highlight))
#+END_SRC

** ibuffer

使用emacs时经常需要管理多个buffer， /C-x C-b/ 的默认界面太过简陋。emacs事实上已
经提供了更好的buffer管理界面ibuffer，在配置文件中选用即可。

启用ibuffer支持，增强 *buffer*, 用了helm，ibuffer可以退休了。  
#+BEGIN_SRC emacs-lisp
(use-package ibuffer
  :defer t
  :config (global-set-key (kbd "C-x C-b") 'ibuffer))
#+END_SRC

** 显示匹配的括号

#+BEGIN_SRC emacs-lisp
(show-paren-mode t)
#+END_SRC

** F5插入当前时间
insert current time，要加上(interactive)啊，为什么呢？

#+BEGIN_EXAMPLE
M-: (insert (format-time-string "[%Y-%m-%d %a %T]"))
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
  (global-set-key [(f5)] '(lambda () (interactive) 
                      (insert (format-time-string "[%Y-%m-%d %a %T]"))))
#+END_SRC

** Reading

https://github.com/xahlee/xah_emacs_init/blob/master/xah_emacs_font.el From Xah Lee:

#+BEGIN_SRC emacs-lisp
(defun xah-toggle-margin-right ()
  "Toggle the right margin between `fill-column' or window width.
This command is convenient when reading novel, documentation."
  (interactive)
  (if (eq (cdr (window-margins)) nil)
      (set-window-margins nil 0 (- (window-body-width) fill-column))
    (set-window-margins nil 0 0)))
#+END_SRC

** 图片支持
[2014-09-18 08:49:12]

=M-x list-dynamics-libraries= 找到对应的dll的name。

可以运行下面几行代码检查一下是否已经支持了图片。

#+BEGIN_SRC lisp
(image-type-available-p 'gif)

(image-type-available-p 'jpeg)

(image-type-available-p 'tiff)

(image-type-available-p 'xbm)

(image-type-available-p 'xpm)

(image-type-available-p 'png)
#+END_SRC

这几个函数复制到Lisp模式的buffer，然后在每一行行尾按 *C-j* ，就可以看到每个函数运行的结果，返回 *t* 证明已经可以支持图片了。

win的emacs不能显示图片是因为编译后默认没有带几个dll文件。把dll copy到emacs安装目录的bin目录下，就可以显示图片了。

*** emacs 24.4
+ png
  [2014-11-18 周二 15:48:21] emacs 24.4需要libpng16-16.dll or libpng16.dll 和 zlib1.dll，都在libpng的压缩包里面
  可以从 http://sourceforge.net/projects/ezwinports/files/ 下载

*** emacs 24.3
+ png :: libpng14.dll

#+BEGIN_EXAMPLE
jpeg62.dll
libgcrypt-11.dll
libgnutls-26.dll
libpng14-14.dll
libtasn1-3.dll
libtiff3.dll
libungif4.dll
libXpm.dll
xpm4.dll
zlib1.dll
#+END_EXAMPLE

可以从 https://github.com/winterTTr/emacs-of-winterTTr/tree/master/.emacs.d/extra-bin/dlls 下载

** 输入特殊字符
[2014-09-29 周一 17:20:40]

+  :: C-q C-a

+ C-q X :: 是一个通用的输入特殊字符的解决办法，X 表示一个特殊字符， 在几乎所有的模式下，输入 =C-q= 然后是一个就可以输入这个特殊字符。
一般来说、所有的特殊的字符都和某一个特定的函数绑定在一起 了，例如 C-a , ASCII 1 , 表示 beginning-of-line 。 换行的字符就是 =C-j= ，ASCII 10。
除了输入 C-j ，还可以输入回车字符的 ASCII 的 8 进制数， 例如 C-q 1 2 。 因为 C-j 对应的 ACSII 是 10, 012 八进制 ， 0xA 十六进制。
#+BEGIN_SRC lisp
(setq read-quoted-char-radix 10)
;or
(setq read-quoted-char-radix 16)
#+END_SRC

可以改为把八进制改为十进制或者十六进制。或者用命令
#+BEGIN_EXAMPLE
M-x set-variable <RET> read-quoted-char-radix <RET>10 
#+END_EXAMPLE

** save the cursor position for every file you opened

Turn on save place so that when opening a file, the cursor will be at the last position.
#+BEGIN_SRC emacs-lisp
;; For GNU Emacs 24.5 and older versions
;; (require 'saveplace)
;; (setq save-place-file (concat user-emacs-directory "saveplace.el") ) ; use standard emacs dir
;; (setq-default save-place t)

;; For GNU Emacs 25.1 and newer versions
(setq-default save-place t)
(use-package saveplace
  ;; :ensure t
  :init (save-place-mode 1))
#+END_SRC

* editor
** evil

#+BEGIN_SRC emacs-lisp
(use-package evil
  :ensure t
  :defer t
  :init (evil-mode 1)
  :config 
    (progn
      ;; (eval-after-load 'helm-gtags
      ;;    '(progn
      ;;       (define-key evil-motion-state-map "C-]" 'helm-gtags-find-tag-from-here)))
      (eval-after-load 'ggtags
        '(progn
           (evil-make-overriding-map ggtags-mode-map 'normal)
           ;; force update evil keymaps after ggtags-mode loaded
           (add-hook 'ggtags-mode-hook #'evil-normalize-keymaps)))
      (setq evil-want-visual-char-semi-exclusive t)))
#+end_src

为ggtags修改默认的键绑定，可以用 M-.
https://blog.csdn.net/Levi_Huang/article/details/84288493

[2019-01-01 周二 00:08:18] helm-gtags不能在statusbar上显示tag的值，这点不如ggtags好用。先用ggtags吧。
* completion
** helm
[2014-09-16 09:27:15]

;; (require 'helm-config)

[2019-06-12 周三 17:15:36] 不直接启动helm，在 *scratch* 里面直接执行 (benchmark-init/show-durations-tree) ，可以看出来helm在启动的时候是没加载的。

#+BEGIN_SRC emacs-lisp
(use-package helm
  ;; :ensure t
  :defer t
  :diminish helm-mode
  :config
  (progn
    (helm-mode +1)
    ;; rebind tab to run persistent action
    (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
    ;; make TAB works in terminal
    (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)
    ;; list actions using C-z
    (define-key helm-map (kbd "C-z")  'helm-select-action)
  )
  :init
  (progn
    ;; (require 'helm-config)
    ;; From https://gist.github.com/antifuchs/9238468
    (setq helm-idle-delay 0.0 ; update fast sources immediately (doesn't).
          ;;
          helm-candidate-number-limit 100
          ;; this actually updates things reeeelatively quickly.
          helm-input-idle-delay 0.01
          ;; Remove extraineous helm UI elements
          helm-display-header-line nil
          ;; Default helm window sizes, 太小了，看着不舒服，不设为nil了。
          ;; helm-display-buffer-default-width nil
          ;; helm-display-buffer-default-height 0.25
          ;;
          helm-yas-display-key-on-candidate t
          ;;
          helm-quick-update t
          ;;
          helm-M-x-requires-pattern nil
          ;;
          helm-ff-skip-boring-files t)
    ;; (helm-mode)
  )
  :bind (("C-c m" . helm-mini)
         ("C-c n" . helm-mini)
         ("C-x C-b" . helm-buffers-list)
         ("C-x b" . helm-buffers-list)
         ("M-y" . helm-show-kill-ring)
         ("M-x" . helm-M-x)
         ("C-x C-f" . helm-find-files)
         ;; ("C-h a" . helm-apropos)
         ;; ("C-x c o" . helm-occur)
         ;; ("C-x c s" . helm-swoop)
         ;; ("C-x c y" . helm-yas-complete)
         ;; ("C-x c Y" . helm-yas-create-snippet-on-region)
         ;; ("C-x c b" . my/helm-do-grep-book-notes)
         ;; ("<tab>" . 'helm-execute-persistent-action)
         ;; ("C-i" . 'helm-execute-persistent-action)
         ;; ("C-z" . 'helm-select-action)
         ("C-x c SPC" . helm-all-mark-rings)))

;; ;; (global-set-key (kbd "C-c h") 'helm-mini)
;; (global-set-key (kbd "C-c m") 'helm-mini)
;; (global-set-key (kbd "C-c n") 'helm-mini)
;; (global-set-key (kbd "M-x") 'helm-M-x)
;; ;; (global-set-key (kbd "C-c a") 'helm-apropos)
;; (global-set-key (kbd "C-x C-f") 'helm-find-files)

;; (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to run persistent action
;; (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB works in terminal
;; (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z

;setq helm-idle-delay 0.0 ; update fast sources immediately (doesn't).
;          helm-input-idle-delay 0.01  ; this actually updates things
;                                      ; reeeelatively quickly.

;; [2019-01-11 周五 23:48:42]
;; (setq helm-quick-update t
;;       helm-M-x-requires-pattern nil ; 在M-x时默认就不显示多余的pattern了，看着烦
;;       helm-ff-skip-boring-files t)

;; Turn off ido mode in case I enabled it accidentally
(ido-mode -1)
#+END_SRC

*** Search buffers by major-mode

+ multi buffer search
  1. *C-c h* 调出helm-mini buffer
  1. 在pattern: 中 输入 *org 选择buffer中的file，可以匹配多个文件
  1. *Esc m* 或者 *M-SPC* mark刚才匹配的files，会高亮
  1. 按 *C-s* search file content
  1. *C-j* 打开buffer并跳到选择的行
  1. *enter* 打开文件

+ M-SPC/Esc-SPC/C-@ :: 用 *M-SPC* 最方便了，mark当前的buffer，如果已经mark了会取消，先C-n/C-p移动到要取消的file

+ M-u :: 取消全部mark的buffer
+ M-a :: mark全部的buffer
     
[2014-09-16 18:24:22] multi search也可以这样，如在所有buffer中org-mode的buffer，然后找 *org @string_to_find 按 *C-s* 就ok了。

+ C-n/C-p/up/down :: 在helm的选项中上下移动
+ left/right :: 在source间移动， *C-o* 移动到下一个source，source就是group分类，如buffer，最近访问的buffer，创建buffer。
+ M-p/M-n :: 命令历史
             
+ mini buffer
  + M-S-d :: kill buffer and quit，就是 *M-D* 。
  + C-c d :: kill buffer without quitting
             
[2014-09-17 15:06:59] 为什么用了heml以后连dired+的 *R* rename file都变成helm的了？

[2014-10-13 周一 17:51:09] helm mini中，选择buffer后，按 =F9= 可以查找，这个更加方便。

*** grep

=helm-resume= 恢复上次的command

**** Grep from helm-find-files

From helm-find-files (helm-command-prefix-key C-x C-f) Open the action
menu with tab and choose grep. A prefix arg will launch recursive
grep.

NOTE:You can now launch grep with (C-u) M-g s without switching to the
action pannel.

**** Grep thing at point

Before lauching helm, put your cursor on the start of symbol or sexp
you will want to grep. Then launch helm-do-grep or helm-find-files,
and when in the grep prompt hit C-w as many time as needed.

光标在一个word前面，然后 =helm-do-grep= ，选择grep的目录和文件 ，就可以grep这个word，按 =C-w=
可以跟着grep这个word后面的word。

**** Grep persistent action

As always, C-z will bring you in the buffer corresponding to the file
you are grepping. Well nothing new, but using C-u C-z will record this
place in the mark-ring. So if you want to come back later to these
places, there is no need to grep again, you will find all these places
in the mark-ring. Accessing the mark-ring in Emacs is really
inconvenient, fortunately, you will find in helm-config
helm-all-mark-ring which is a mark-ring browser
(helm-command-prefix-key C-c SPACE). helm-all-mark-ring is in helm
menu also, in the tool section.

TIP: Bind helm-all-mark-ring to C-c SPACE.

在org mode下，无效。
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c <SPC>") 'helm-all-mark-rings)
#+END_SRC

NOTE: helm-all-mark-ring handle global-mark-ring also.

*** helm-swoop
[2014-11-21 周五 09:26:34]

#+BEGIN_SRC emacs-lisp
(use-package helm-swoop
  :ensure t
  :defer t
  :bind (("M-i" . helm-swoop)
         ("M-I" . helm-swoop-back-to-last-point)
         ("C-c M-i" . helm-multi-swoop)
         ("C-x M-i" . helm-multi-swoop-all)))
#+END_SRC

*** helm-gtags - 不用了 [2018-12-31 周一 23:31:48]

[2019-01-11 周五 22:16:55] 不如ggtags好用，ggtags用着比较习惯。

#+BEGIN_SRC lisp
;; (use-package helm-gtags
;;   :ensure t
;;   :defer t
;;   :init
;;     (setq helm-gtags-ignore-case t
;;           helm-gtags-auto-update t
;;           helm-gtags-use-input-at-cursor t
;;           helm-gtags-pulse-at-cursor t
;;           helm-gtags-prefix-key "\C-cg"
;;           helm-gtags-suggested-key-mapping t))
;; 
;; (defun set-helm-gtags-keybindings ()
;;   (define-key helm-gtags-mode-map (kbd "C-c g a") 'helm-gtags-tags-in-this-function)
;;   (define-key helm-gtags-mode-map (kbd "C-c g s") 'helm-gtags-select)
;;   (define-key helm-gtags-mode-map (kbd "M-."    ) 'helm-gtags-dwim)
;;   (define-key helm-gtags-mode-map (kbd "M-,"    ) 'helm-gtags-pop-stack)
;;   (define-key helm-gtags-mode-map (kbd "C-c g p") 'helm-gtags-previous-history)
;;   (define-key helm-gtags-mode-map (kbd "C-c g n") 'helm-gtags-next-history))
;; 
;; (add-hook 'helm-gtags-mode-hook 'set-helm-gtags-keybindings)
#+END_SRC

*** helm-ag [2019-01-01 周二 00:15:53]
https://emacs-china.org/t/emacs-helm-ag/6764/7 如何定位并解决Emacs helm-ag的中文搜索问题

* lang
** 多行代码的注释/反注释

其实可以考虑vim的 =<leader> + \= 进行注释的。
#+BEGIN_SRC emacs-lisp
(global-set-key [?\C-c ?\C-/] 'comment-or-uncomment-region)

(defun my-comment-or-uncomment-region (beg end &optional arg)  
  (interactive (if (use-region-p)  
                   (list (region-beginning) (region-end) nil)  
                   (list (line-beginning-position)  
                       (line-beginning-position 2))))  
  (comment-or-uncomment-region beg end arg)  
)  
(global-set-key [remap comment-or-uncomment-region] 'my-comment-or-uncomment-region)  
#+END_SRC

** c-mode coding style [2019-01-05 周六 11:20:13]

emacs使用google-c-style
google c++编码规范很全面，现在已经逐渐习惯了这种编码规范，突然想到或许emacs中有合适的el支持这种规范，到网上一找，果然有。

http://google-styleguide.googlecode.com/svn/trunk/google-c-style.el

elpa中安装就可以了。

下载下来，放在emacs.d目录下，然后在.emacs配置文件中添加几行：

(add-to-list 'load-path (expand-file-name "~/.emacs.d"))
(require 'google-c-style)
(add-hook 'c-mode-common-hook 'google-set-c-style)
(add-hook 'c-mode-common-hook 'google-make-newline-indent)

(add-hook 'c-mode-common-hook
          (lambda ()
            (setq c-default-style "k&r" c-basic-offset 4)
            (c-set-offset 'substatement-open 0)))

#+BEGIN_SRC emacs-lisp
(setq c-default-style "linux")
(setq c-basic-offset 4)

(setq default-tab-width 4)
(setq-default indent-tabs-mode nil)

;; (setq tab-width 4)
;; (setq tab-stop-list ())
#+END_SRC

*** flycheck在虚机中的配置 [2019-05-24 周五 14:39:51]
在笔记本上就不配置c-mode的flycheck了，没有gcc。add-hook在ggtags的配置里面enable了flycheck-mode。
#+BEGIN_SRC lisp
;; 在目录中建 .dir-locals.el
((c-mode . ((flycheck-gcc-include-path . (;; list
                                          ;; (expand-file-name "~/tengine")
                                          "/home/albert/tengine/src/"
                                          "/home/albert/tengine/src/core/")))))
#+END_SRC

** emacs-lisp
[2014-09-27 01:58:44]

lisp语言入门，写得很不错，找不到原出处了 http://www.cnblogs.com/suiqirui19872005/archive/2007/12/05/984517.html

emacs自带的帮助也不错，可以了解emacs lisp的特点，和common lisp的区别慢慢体会。

*** 括号高亮
http://www.emacswiki.org/emacs/HighlightParentheses

http://ergoemacs.org/emacs/emacs_editing_lisp.html

#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook
          '(lambda ()
             (highlight-parentheses-mode)))

(define-globalized-minor-mode global-highlight-parentheses-mode
  highlight-parentheses-mode
  (lambda ()
    (highlight-parentheses-mode t)))
(global-highlight-parentheses-mode t)
#+END_SRC

*** eldoc-mode
http://sachachua.com/blog/2014/06/read-lisp-tweak-emacs-beginner-24-understand-emacs-lisp-code/

turns on eldoc-mode, which displays the argument list for the current function. 
You can move your cursor around to see argument lists for other functions.
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
#+END_SRC

** lsp-mode [2019-06-14 周五 21:30:36]

=M-x lsp-workspace-folders-add= 把目录加到lsp里去。

seagle0128 18年11月
请参考 https://github.com/seagle0128/.emacs.d/blob/master/lisp/init-lsp.el 和 https://github.com/seagle0128/.emacs.d/blob/master/lisp/init-python.el

https://vxlabs.com/2018/11/19/configuring-emacs-lsp-mode-and-microsofts-visual-studio-code-python-language-server/ 
https://github.com/emacs-lsp/lsp-python-ms
#+BEGIN_SRC emacs-lisp
;; Emacs client for the Language Server Protocol
;; https://github.com/emacs-lsp/lsp-mode#supported-languages
(use-package lsp-mode
  ;; :diminish lsp-mode
  :defer t
  ;; :hook (prog-mode . lsp)
  :hook (python-mode . lsp)
  :bind (:map lsp-mode-map
              ("C-c C-d" . lsp-describe-thing-at-point))
  :init
  (setq lsp-auto-guess-root t)       ; Detect project root
  ;; disable Yasnippet
  (setq lsp-enable-snippet nil)
  (setq lsp-prefer-flymake nil)      ; Use lsp-ui and flycheck
  (setq flymake-fringe-indicator-position 'right-fringe)
  
  ;; 在lsp-clients.el里面直接require的，无效，照样加载
  ;; (setq lsp-disabled-clients '(ruby java dart clojure metals go xml vetur rust solargraph elm))
  ;; :config
  ;; Configure LSP clients
)

;; (use-package lsp-clients
;;   :defer t
;;   :ensure nil
;;   )

    ;; :init
    ;; (setq lsp-clients-python-library-directories '("/usr/local/" "/usr/"))))
    

(use-package lsp-ui
  :defer t
  :custom-face
  (lsp-ui-doc-background ((t (:background nil))))
  :bind (:map lsp-ui-mode-map
              ([remap xref-find-definitions] . lsp-ui-peek-find-definitions)
              ([remap xref-find-references] . lsp-ui-peek-find-references)
              ("C-c u" . lsp-ui-imenu))
  :init (setq lsp-ui-doc-enable t
              lsp-ui-doc-use-webkit t
              lsp-ui-doc-include-signature t
              lsp-ui-doc-position 'top
              lsp-ui-doc-border (face-foreground 'default)

              lsp-ui-sideline-enable nil
              lsp-ui-sideline-ignore-duplicate t)
  :config
  ;; WORKAROUND Hide mode-line of the lsp-ui-imenu buffer
  ;; https://github.com/emacs-lsp/lsp-ui/issues/243
  (defadvice lsp-ui-imenu (after hide-lsp-ui-imenu-mode-line activate)
    (setq mode-line-format nil)))

(use-package company-lsp
  :defer t
  :init (setq company-lsp-cache-candidates 'auto))
  
(use-package lsp-treemacs
  :defer t
  :bind (:map lsp-mode-map
  ("M-9" . lsp-treemacs-errors-list)))
#+END_SRC

[2019-06-15 周六 22:19:27] 为什么用了mspyls后就找不到其他的package，而用pyls就可以找到？
pyls比mspyls会多起不少python进程，可能是jedi起来的，很讨厌。

[2019-06-15 周六 23:57:36]
在下面的函数中打印 =workspace-root= 。
#+BEGIN_SRC lisp
(defun lsp-python-ms--extra-init-params (&optional workspace)
directory"
  (let ((workspace-root (if workspace (lsp--workspace-root workspace) (lsp-python-ms--workspace-root))))
    (message "lsp-python-ms: workspace-root is %s." workspace-root)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package lsp-python-ms
  ;; :ensure nil
  ;; :defer t
  :demand
  :after lsp-mode
  :hook (python-mode . lsp)
  :config
  ;; for ali rds
  ;; (setq lsp-python-ms-extra-paths "E:/CU/ali/3.5.2/RDS/usr/local/rds/agent-node-mysql/0.0.13/lib/python2.7")
  ;; for dev build of language server
  (setq lsp-python-ms-dir
        (expand-file-name "e:/workspace/python-language-server/output/bin/Release/"))
  ;; for executable of language server, if it's not symlinked on your PATH
  (setq lsp-python-ms-executable
        "e:/workspace/python-language-server/output/bin/Release/Microsoft.Python.LanguageServer"))
#+END_SRC
** markdown-mode

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  ;; :ensure t
  :defer t
  :commands (markdown-mode gfm-mode)
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init (setq markdown-command "multimarkdown"))
#+END_SRC
  
** python
*** elpy
=C-c C-d= (elpy-doc) 查看文档

[2018-11-29 周四 16:15:34]
#+BEGIN_SRC emacs-lisp
;; (setq python-shell-interpreter "python"
(setq python-shell-interpreter "ipython"
      python-shell-interpreter-args "-i --simple-prompt")

;; (use-package python-mode
;;   :mode (("SConstruct\\'" . python-mode)
;;          ("SConscript\\'" . python-mode)
;;          ("\\.py\\'"      . python-mode))
;;   :defer t
;;   ;; [2018-12-01 周六 22:13:10] 为什么execl-test.py不能显示中文doc，而且不停报错?
;;   :init (elpy-enable)
;;   :config
;;   (use-package elpy
;;     :ensure t
;;     :defer t
;;     :init
;;     (progn
;;       ;;(setq elpy-rpc-python-command "python3")
;;       (elpy-use-ipython)
;;       ;; (add-hook 'elpy-mode-hook (lambda () (elpy-shell-toggle-dedicated-shell 1)))
;;       ;; use flycheck not flymake with elpy
;;       ;; (when (require 'flycheck nil t)
;;       ;;   (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
;;       ;;   (add-hook 'elpy-mode-hook 'flycheck-mode))
;;       )))

;; (elpy-enable)
#+END_SRC

#+BEGIN_SRC lisp
(use-package elpy
  :ensure t
  :defer t
  :init
  (progn
    (advice-add 'python-mode :before 'elpy-enable))
  :config
  (progn
    ;; (setq elpy-rpc-python-command "python3")
    ;; (elpy-use-ipython)
    ;; (add-hook 'elpy-mode-hook (lambda () (elpy-shell-toggle-dedicated-shell 1)))
    ;; use flycheck not flymake with elpy
    (when (require 'flycheck nil t)
      (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
      (add-hook 'elpy-mode-hook 'flycheck-mode))
    ))
#+END_SRC

*** autopep8 [2019-05-17 周五 11:29:37]

=M-x elpy-config= 可以检查elpy的package安装状态，把缺少的package安装上去。

用pip安装autopep8
#+BEGIN_SRC sh
pip install autopep8
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package py-autopep8
  :ensure t
  :defer t
  :init
    (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save))
#+END_SRC

*** yapf
google的代码格式化工具。
*** pdb setup, note the python version
#+BEGIN_SRC lisp
;; (setq pdb-path 'c:/Python/Python36/Lib/pdb.py
;;        gud-pdb-command-name (symbol-name pdb-path))
;;  (defadvice pdb (before gud-query-cmdline activate)
;;    "Provide a better default command line when called interactively."
;;    (interactive
;;     (list (gud-query-cmdline pdb-path
;;                  (file-name-nondirectory buffer-file-name)))))
#+end_src

** scheme [2017-03-02 周四 21:27:47]

;; (require 'cmuscheme)
#+BEGIN_SRC emacs-lisp
(use-package cmuscheme
  :defer t)
(setq scheme-program-name "racket")         ;; 如果用 Petite 就改成 "petite"
;; (setq scheme-program-name "scheme")         ;; 如果用 Petite 就改成 "petite"

;; bypass the interactive question and start the default interpreter
(defun scheme-proc ()
  "Return the current Scheme process, starting one if necessary."
  (unless (and scheme-buffer
	 (get-buffer scheme-buffer)
	 (comint-check-proc scheme-buffer))
    (save-window-excursion
(run-scheme scheme-program-name)))
  (or (scheme-get-process)
(error "No current process. See variable `scheme-buffer'")))

(defun scheme-split-window ()
  (cond
   ((= 1 (count-windows))
    (delete-other-windows)
    ;; (split-window-vertically (floor (* 0.68 (window-height))))
    (split-window-horizontally (floor (* 0.60 (window-width))))
    (other-window 1)
    (switch-to-buffer "*scheme*")
    (other-window 1))
   ((not (cl-find "*scheme*"
	 (mapcar (lambda (w) (buffer-name (window-buffer w)))
		 (window-list))
	 :test 'equal))
    (other-window 1)
    (switch-to-buffer "*scheme*")
    (other-window -1))))

(defun scheme-send-last-sexp-split-window ()
  (interactive)
  (scheme-split-window)
  (scheme-send-last-sexp))

(defun scheme-send-definition-split-window ()
  (interactive)
  (scheme-split-window)
  (scheme-send-definition))

(add-hook 'scheme-mode-hook
  (lambda ()
    (paredit-mode 1)
    (evil-paredit-mode 1)
    (define-key scheme-mode-map (kbd "<f6>") 'scheme-send-last-sexp-split-window)
    (define-key scheme-mode-map (kbd "<f7>") 'scheme-send-definition-split-window)))
#+END_SRC

[2017-04-09 周日 00:20:25]
#+BEGIN_SRC emacs-lisp
(use-package paren-face
  :ensure t
  :defer t
  :init (global-paren-face-mode 1))
#+END_SRC
** web-mode [2018-02-08 周四 17:03:42]

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :defer t)
#+END_SRC
* ui
** Frame title

#+begin_src emacs-lisp
(setq frame-title-format "Albert@%f")
#+end_src

;;(setq frame-title-format "Albert@%b")
** minibuffer
[2014-09-12 09:24:17]

It often displays so much information, even temporarily, that it is nice to give it some room to breath.

#+BEGIN_SRC emacs-lisp
(setq resize-mini-windows t)
(setq max-mini-window-height 0.33)
#+END_SRC

** 去掉启动欢迎界面

#+begin_src emacs-lisp
(setq inhibit-startup-message t) 
#+end_src

** 光标靠近鼠标的时候，让鼠标自动让开，不挡住视线

#+begin_src emacs-lisp
(mouse-avoidance-mode 'animate)
#+end_src

** 不要总是没完没了的问yes or no

#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** 显示行、列号

在status bar显示，不在buffer的左侧显示每行的行号，否则真的会很慢。

列号是从0开始的。
#+BEGIN_SRC emacs-lisp
(column-number-mode t)
#+END_SRC

[2014-03-17 17:54:25] 不显示行号，否则速度会非常慢

#+BEGIN_SRC lisp
;;另外一个显示行号的插件，个人更喜欢的风格
;(require 'linum)
;(global-linum-mode t)
#+END_SRC

[2019-05-15 周三 15:33:55] emacs 26.2可以用，显示速度比linum快很多。
#+BEGIN_SRC emacs-lisp
;; (global-display-line-numbers-mode t)
(setq display-line-numbers-width-start 5)

(add-hook 'org-mode-hook 'display-line-numbers-mode)
(add-hook 'python-mode-hook 'display-line-numbers-mode)
(add-hook 'c-mode-common-hook 'display-line-numbers-mode)
(add-hook 'emacs-lisp-mode-hook 'display-line-numbers-mode)
(add-hook 'sh-mode-hook 'display-line-numbers-mode)
#+END_SRC

** Make window splitting more useful

I added these snippets to my .emacs so that when I split the screen with C-x 2 or C-x 3, 
it opens the previous buffer instead of giving me two panes with the same buffer:

Copied from http://www.reddit.com/r/emacs/comments/25v0eo/you_emacs_tips_and_tricks/chldury

#+BEGIN_SRC emacs-lisp
(defun vsplit-last-buffer ()
  (interactive)
  (split-window-vertically)
  (other-window 1 nil)
  (switch-to-next-buffer)
  )
(defun hsplit-last-buffer ()
  (interactive)
   (split-window-horizontally)
  (other-window 1 nil)
  (switch-to-next-buffer)
  )

(global-set-key (kbd "C-x 3") 'vsplit-last-buffer)
(global-set-key (kbd "C-x 2") 'hsplit-last-buffer)
#+END_SRC

** Color theme

emacs24自带的最喜欢的theme。

[2017-04-30 周日 23:55:59] 试了一下solarized，在light mode下不好看，太晃眼，helm不知道选中了哪个，dark mode也一样，org mode中代码的高亮没有了。deeper-blue更好。
#+BEGIN_SRC emacs-lisp
;; (load-theme 'deeper-blue t)
#+END_SRC

;; (load-theme 'solarized t)
;; (load-theme 'tango-dark t)
;; (load-theme 'manoj-dark t)

[2019-01-11 周五 21:55:40] 下面的theme不是用load-theme加载，不如什么theme都不用，纯白的。
;; (load-theme 'Snowish t)
;; (load-theme 'Bharadwaj-Slate t)
;; (load-theme 'Infodoc t)

JB Simple 白底黑字不错
Jedit Grey 灰底黑字也可以

*** doom-themes [2019-05-21 周二 09:19:44]
昨天看了doom-emacs，觉得theme和modeline很漂亮，就试了一下。但是所有的theme的org block都是加亮的，
和现在使用的deeper-blue差异太大，就自己增加了一个theme。

;#+BEGIN_SRC lisp
#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :ensure t
  ;; :disabled t
  :defer t
  :init
  ;; :config
  (progn
    ;; Global settings (defaults)
    (setq doom-themes-enable-bold nil  ; if nil, bold is universally disabled
                                       ; 禁用粗体，否则org-mode的outline字体太难看
          doom-themes-enable-italic t) ; if nil, italics is universally disabled

    ;; 在load-theme之前设置，让modeline更亮一点，
    ;; [2019-05-21 周二 16:54:51] 不知道改了doom-deeper-blue-theme.el的哪个地方，貌似modeline中的文件名能看清楚了。
    (setq doom-deeper-blue-brighter-modeline nil)

    ;; Load the theme (doom-one, doom-molokai, etc); keep in mind that each theme may have their own settings.
    ;; (load-theme 'doom-one t)
    (load-theme 'doom-deeper-blue t)
    
    ;; Enable flashing mode-line on errors
    (doom-themes-visual-bell-config)
    
    ;; Enable custom neotree theme (all-the-icons must be installed!)
    ;; (doom-themes-neotree-config)
    ;; or for treemacs users
    (doom-themes-treemacs-config)
    
    ;; Corrects (and improves) org-mode's native fontification.
    (doom-themes-org-config)))
#+END_SRC
** Font setting on windows and X

可以用 *C-u C-x =* or *C-u g a* 来查看光标上的汉字是用什么字体显示的，从而确定应该用什么字体显示中文。

另一个有用的函数是 =M-x describe-fontset= 。

中文用雅黑，英文用consolas比直接用雅黑的混合字体显示效果好。混合字体对一个特定的字体大小显示效果好。

CJK (Chinese, Japanese, Korean)

#+BEGIN_SRC lisp
;; (if (eq system-type 'windows-nt)
;;   ;(set-fontset-font t 'han (font-spec :family "Microsoft Yahei" :size 12))
;;   ;(setq face-font-rescale-alist '(("微软雅黑" . 1.2) ("Microsoft Yahei" . 1.2)))
;;   (progn
;;     ;; Setting English Font
;;     ;; (set-face-attribute 'default nil :font "Consolas 11")
;;     ;; (set-face-attribute 'default nil :font "Source Code Variable 8")
;;     ;; (set-face-attribute 'default nil :font "Monaco 10")
;;     ;; (set-face-attribute 'default nil :font "Liberation Mono 10")
;;     (set-face-attribute 'default nil :font "Ubuntu Mono 12")
;;     ;; (set-face-attribute 'default nil :font "Fira Code 8")
;;     ;; (set-face-attribute 'default nil :font "Fira Code Retina 10")
;;     ;; (set-face-attribute 'default nil :font "DejaVu Sans Mono 10")
;; 
;;     ;; Chinese Font
;;     (dolist (charset '(kana han symbol cjk-misc bopomofo))
;;             (set-fontset-font (frame-parameter nil 'font)
;;                           charset
;;                           (font-spec :family "Microsoft Yahei" :size 16)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun albert-notebook-font()
  "Config font on HP zhan66."
  (interactive)
  (if (eq system-type 'windows-nt)
    (progn
      ;; Setting English Font
      (set-face-attribute 'default nil :font "Ubuntu Mono 11")
      ;; Chinese Font
      (dolist (charset '(kana han symbol cjk-misc bopomofo))
              (set-fontset-font (frame-parameter nil 'font)
                            charset
                            (font-spec :family "Microsoft Yahei" :size 22))))))

(defun albert-s2319-font()
  "Config font on dell s2319. 
   Ubuntu Mono 10 + Yahei 14 太小了
   Ubuntu Mono 12 + Yahei 16 比较合适
   "
  (interactive)
  (if (eq system-type 'windows-nt)
    (progn
      ;; Setting English Font
      (set-face-attribute 'default nil :font "Ubuntu Mono 12")
      ;; (set-face-attribute 'default nil :font "Monaco 10")
      ;; (set-face-attribute 'default nil :font "文泉驿等宽正黑 12")
      ;; Chinese Font
      (dolist (charset '(kana han symbol cjk-misc bopomofo))
              (set-fontset-font (frame-parameter nil 'font)
                            charset
                            (font-spec :family "Microsoft Yahei" :size 16))))))
                            ;;(font-spec :family "文泉驿等宽正黑" :size 16))))))

(if (eq window-system 'w32)
  (progn
    ;; 根据显示器实际宽度(以毫米为单位)，显示字体.
    ;; DELL S2319HS 分辨率1920x1080, 屏幕尺寸是509mm X 286mm
    (if (>= (display-mm-width) 509)
      (albert-s2319-font))
    
    ;; 宽度在500mm的认为是笔记本?或者更加精确一点的方式来匹配不同的笔记本型号?
    ;; HP ZHAN66 309mm X 175mm
    ;; Thinkpad T430 4xxmm X 20xmm?
    (if (<= (display-mm-width) 500)
      (albert-notebook-font))))

;; [2018-12-10 周一 11:30:55] 测试了https://github.com/crvdgc/Consolas-with-Yahei
;; 效果不好。
;; (set-default-font "Consolas-with-Yahei 9")

;; (if (eq system-type 'windows-nt)
;;      (set-face-attribute
;;        'default nil :font "Consolas-with-Yahei 11"))
#+END_SRC

[2018-12-10 周一 11:39:52] Consolas 10 + Microsoft Yahei 24 org mode table是可以对齐的，但是中文太大了。
Consolas 8 + Microsoft Yahei 20 org mode table是可以对齐的，但是英文太小了。
默认用Consolas 11 + Microsoft Yahei 20的时候不能对齐。

Source Code Variable 无法和Yahei配合对齐。

[2018-12-10 周一 12:17:01] https://github.com/cstrap/monaco-font 
字体下载 https://raw.githubusercontent.com/todylu/monaco.ttf/master/monaco.ttf
"Monaco 8 + Microsoft Yahei 20" org mode table是可以对齐的，但是英文太小了。
"Monaco 10 + Microsoft Yahei 24" org mode table是可以对齐的，但是中文太大了。

[2018-12-10 周一 13:30:29] https://design.ubuntu.com/font/
"Ubuntu Mono 10 + Microsoft Yahei 20" org mode table是可以对齐的，但是英文太小了。
"Ubuntu Mono 12 + Microsoft Yahei 24" org mode table是可以对齐的，但是中文太大了。
"Ubuntu Mono 11 + Microsoft Yahei 22" org mode table是可以对齐的，字体大小正好。

[2019-01-30 周三 14:28:50] 试了一下文泉驿等宽正黑12 + 文泉驿等宽正黑16，中文字体显示发虚。

** 不显示工具栏和滚动条
[2014-11-18 周二 17:39:59] 把scrollbar也去掉了

#+begin_src emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)

(if (eq window-system 'w32)
  (scroll-bar-mode -1))
#+end_src

** Window size

T430的屏幕长了一点，要是全屏的话，org mode的buffer会在右边打开，看见的内容太少了，
控制窗口大小，让buffer显示在下面。

#+BEGIN_SRC emacs-lisp
;; adjust the size of Emacs window for org mode agenda/todo list to display herizontal
(if (eq system-type 'windows-nt)
  ;; (setq default-frame-alist '((top . 0) (left . 0) (height . 42) (width . 159)))
  (toggle-frame-maximized)

  ;; "Maximize emacs window in windows os" WM_SYSCOMMAND #xf030 maximize  
  ;; [2018-09-07 周五 09:53:36] 不知道为什么没有效果
  ;; (interactive)
  ;; (w32-send-sys-command 61488)
)
#+END_SRC

** 字体放大缩小

from sacha chua
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-=") 'text-scale-increase)
(global-set-key (kbd "C--") 'text-scale-decrease)
#+END_SRC

** mode-line
*** doom-modeline
[2019-05-21 周二 17:05:01] 其实主要是为了用doom-modeline才修改doom-themes的。
如果不用doom-themes而是使用Emacs的deeper-blue，modeline的前景色会很难看，而且文件名看不清楚。

https://seagle0128.github.io/doom-modeline/ 国人写的，在emacs-china上看见了。

+ 优点
  1. 速度很快
  2. 显示很漂亮
     
+ Install
  1. all-the-icons包和里面的艺术字体，windows上手动安装字体。

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :ensure t
  :defer t)
  
(use-package doom-modeline
  :ensure t
  :defer t
  ;; :init
  :config
  (progn
    ;; How tall the mode-line should be (only respected in GUI Emacs).
    ;; (setq doom-modeline-height 20)
    
    ;; How wide the mode-line bar should be (only respected in GUI Emacs).
    ;; (setq doom-modeline-bar-width 3)

    ;; Whether show `all-the-icons' or not (if nil nothing will be showed).
    (setq doom-modeline-icon t)
    
    ;; Whether show the icon for major mode. It respects `doom-modeline-icon'.
    (setq doom-modeline-major-mode-icon t)
    
    ;; Display color icons for `major-mode'. It respects `all-the-icons-color-icons'.
    (setq doom-modeline-major-mode-color-icon t)
    
    ;; Whether display minor modes or not. Non-nil to display in mode-line.
    (setq doom-modeline-minor-modes nil)
    
    ;; Slow Rendering. If you experience a slow down in performace when rendering multiple icons simultaneously, you can try setting the following variable
    (setq inhibit-compacting-font-caches t)
    
    ;; Whether display `lsp' state or not. Non-nil to display in mode-line.
    (setq doom-modeline-lsp nil)
    
    ;; Whether display mu4e notifications or not. Requires `mu4e-alert' package.
    (setq doom-modeline-mu4e nil)
    
    ;; Whether display irc notifications or not. Requires `circe' package.
    (setq doom-modeline-irc nil)
    )
  :hook (after-init . doom-modeline-mode))
#+END_SRC

*** modeline中的时间格式设置
[2014-11-21 周五 10:35:59]

在modeline上显示日期时间。

;; (setq display-time-24hr-format t)
;; (setq display-time-use-mail-icon t)
;; (setq display-time-interval 60)

#+BEGIN_SRC emacs-lisp
(setq display-time-day-and-date t)
(setq display-time-format "%Y-%m-%d %a %H:%M")
(setq display-time-default-load-average nil)
(display-time)
#+END_SRC

*** 不显示一些无用的minor mode
#+BEGIN_SRC emacs-lisp
(use-package diminish
  :ensure t
  :defer t)

;(eval-after-load "yasnippet" '(diminish 'yas-minor-mode))
;(eval-after-load "undo-tree" '(diminish 'undo-tree-mode))
;(eval-after-load "guide-key" '(diminish 'guide-key-mode))
;(eval-after-load "smartparens" '(diminish 'smartparens-mode))
;(eval-after-load "guide-key" '(diminish 'guide-key-mode))
(eval-after-load "eldoc" '(diminish 'eldoc-mode))
(eval-after-load "org-indent" '(diminish 'org-indent-mode))
(eval-after-load "highlight-parentheses" '(diminish 'highlight-parentheses-mode))
(eval-after-load "auto-revert" '(diminish 'auto-revert-mode))

(diminish 'visual-line-mode)
#+END_SRC

** treemacs [2019-06-12 周三 09:41:52]

+ =q= 退出treemacs

#+BEGIN_SRC emacs-lisp
(use-package treemacs
  :ensure t
  :defer t
  :init
  (with-eval-after-load 'winum
    (define-key winum-keymap (kbd "M-0") #'treemacs-select-window))
  :config
  (progn
    (setq treemacs-collapse-dirs                 (if (executable-find "python3") 3 0)
          treemacs-deferred-git-apply-delay      0.5
          treemacs-display-in-side-window        t
          treemacs-eldoc-display                 t
          treemacs-file-event-delay              5000
          treemacs-file-follow-delay             0.2
          treemacs-follow-after-init             t
          treemacs-git-command-pipe              ""
          treemacs-goto-tag-strategy             'refetch-index
          treemacs-indentation                   2
          treemacs-indentation-string            " "
          treemacs-is-never-other-window         nil
          treemacs-max-git-entries               5000
          treemacs-missing-project-action        'ask
          treemacs-no-png-images                 nil
          treemacs-no-delete-other-windows       t
          treemacs-project-follow-cleanup        nil
          treemacs-persist-file                  (expand-file-name ".cache/treemacs-persist" user-emacs-directory)
          treemacs-recenter-distance             0.1
          treemacs-recenter-after-file-follow    nil
          treemacs-recenter-after-tag-follow     nil
          treemacs-recenter-after-project-jump   'always
          treemacs-recenter-after-project-expand 'on-distance
          treemacs-show-cursor                   nil
          treemacs-show-hidden-files             t
          treemacs-silent-filewatch              nil
          treemacs-silent-refresh                nil
          treemacs-sorting                       'alphabetic-desc
          treemacs-space-between-root-nodes      t
          treemacs-tag-follow-cleanup            t
          treemacs-tag-follow-delay              1.5
          treemacs-width                         30)

    ;; The default width and height of the icons is 22 pixels. If you are
    ;; using a Hi-DPI display, uncomment this to double the icon size.
    ;;(treemacs-resize-icons 44)

    (treemacs-follow-mode t)
    (treemacs-filewatch-mode t)
    (treemacs-fringe-indicator-mode t)
    (pcase (cons (not (null (executable-find "git")))
                 (not (null (executable-find "python3"))))
      (`(t . t)
       (treemacs-git-mode 'deferred))
      (`(t . _)
       (treemacs-git-mode 'simple))))
  :bind
  (:map global-map
        ("M-0"       . treemacs-select-window)
        ("C-x t 1"   . treemacs-delete-other-windows)
        ("C-x t t"   . treemacs)
        ("C-x t B"   . treemacs-bookmark)
        ("C-x t C-t" . treemacs-find-file)
        ("C-x t M-t" . treemacs-find-tag)))

(use-package treemacs-evil
  :after treemacs evil
  :ensure t)

(use-package treemacs-projectile
  :after treemacs projectile
  :ensure t)

(use-package treemacs-icons-dired
  :after treemacs dired
  :ensure t
  :config (treemacs-icons-dired-mode))

(use-package treemacs-magit
  :after treemacs magit
  :ensure t)
#+END_SRC
** window-select
*** window-number - 不用了

和 window-numbering.el 不是一个package。
直接按 *M-num* 就ok，完了，用了这个都忘记怎么切窗口了， ^_^ *C-x o*, *C-x 1*

#+BEGIN_SRC lisp
(use-package window-numbering
  :ensure t
  :config (window-numbering-mode 1))
  ;; :init (window-numbering-mode 1))
#+END_SRC

*** winum [2019-06-12 周三 09:50:41]
从treemacs学到的。winum是window-number.el的新的扩展和活跃的维护版本。

#+BEGIN_SRC emacs-lisp
(use-package winum
  :config (winum-mode +1)
  :init
  (setq winum-keymap
      (let ((map (make-sparse-keymap)))
        (define-key map (kbd "C-`") 'winum-select-window-by-number)
        (define-key map (kbd "C-²") 'winum-select-window-by-number)
        (define-key map (kbd "M-0") 'winum-select-window-0-or-10)
        (define-key map (kbd "M-1") 'winum-select-window-1)
        (define-key map (kbd "M-2") 'winum-select-window-2)
        (define-key map (kbd "M-3") 'winum-select-window-3)
        (define-key map (kbd "M-4") 'winum-select-window-4)
        (define-key map (kbd "M-5") 'winum-select-window-5)
        (define-key map (kbd "M-6") 'winum-select-window-6)
        (define-key map (kbd "M-7") 'winum-select-window-7)
        (define-key map (kbd "M-8") 'winum-select-window-8)
        map)))
#+END_SRC

** winner-mode [2019-01-09 周三 18:04:05]
winner-mode是emacs自带，打开(winner-mode t)之后，就可以用 =C-x <left>= 和 =C-x <right>= 来对窗口布局实现undo/redo了。

#+BEGIN_SRC emacs-lisp
(use-package winner
  :defer t)
 
;; (winner-mode t)
#+END_SRC
* tools
** Flycheck - http://www.flycheck.org
[2019-05-17 周五 14:49:48] 使用flycheck替换默认的flymake。

flycheck是emacs的语法检查工具，用来替换老的flymake，比flymake支持更多的语言，更多的第三方工具。检查python的语法，要先安装flake8。
#+BEGIN_SRC sh
pip install flake8
#+END_SRC

#+BEGIN_SRC lisp
;; (use-package flycheck
;;   :ensure t
;;   :defer t
;;   ;; :init
;;   ;;   (when (require 'flycheck nil t)
;;   ;;     (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
;;   ;;     (add-hook 'elpy-mode-hook 'flycheck-mode)))
;;   )
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; tools/flycheck/autoload.el
(defun +flycheck|init-popups ()
  "Activate `flycheck-posframe-mode' if available and in GUI Emacs.
Activate `flycheck-popup-tip-mode' otherwise.
Do nothing if `lsp-ui-mode' is active and `lsp-ui-sideline-enable' is non-nil."
  (unless (and (bound-and-true-p lsp-ui-mode)
               lsp-ui-sideline-enable)
    (if (and (fboundp 'flycheck-posframe-mode)
             (display-graphic-p))
        (flycheck-posframe-mode +1)
      (flycheck-popup-tip-mode +1))))

(use-package flycheck-posframe
  ;; :when (and EMACS26+ (featurep! +childframe))
  :defer t
  :init (add-hook 'flycheck-mode-hook #'+flycheck|init-popups)
  :config
  (setq flycheck-posframe-warning-prefix "☎ "
        flycheck-posframe-info-prefix "··· "
        flycheck-posframe-error-prefix "✕ "))
#+END_SRC
** graphviz [2019-01-08 周二 18:13:47]

主要思想是解析 =buffer= 中选中的文本，通过正则表达式来匹配，从中找到 struct name 以及其中的各个 fields， 最后根据 =dot= 语法将其组成一个 =subgraph= 。其实应该有更好的方法（比如通过 CEDET 的 Semantic 解析结果来做），但对 CEDET 的代码实在不熟，所以现在就只能这样了。
#+BEGIN_SRC emacs-lisp
;; Function used to add fields of struct into a dot file (for Graphviz).
(defconst yyc/dot-head "subgraph cluster_%s {
    node [shape=record fontsize=12 fontname=Courier style=filled];
    color = lightgray;
    style=filled;
    label = \"Struct %s\";
    edge[color=\"#2e3436\"];"
  "Header part of dot file.")

(defconst yyc/dot-tail "
}"
  "Tail part of dot")

(defconst yyc/dot-node-head
  "
        node_%s[shape=record label=\"<f0>*** STRUCT %s ***|\\"
  "Format of node.")

(defconst yyc/dot-node-tail "
\"];"
  "Format of node.")
 
(defconst r_attr_str "[ \t]+\\(.*+\\)[ \t]+\\(.*\\)?;"
  "Regular expression for matching struct fields.")
 
;; (defconst r_name (caar (semantic-parse-region start end))
(defconst r_name "\\_<\\(typedef[ \t]+\\)?struct[ \t]+\\(.*\\)?[ \t]*{"
  "Regular expression for mating struct name")
 
(defconst attr_str "
<f%d>%s %s\\l|\\" "nil")
 
(defun yyc/datastruct-to-dot (start end)
  "generate c++ function definition and insert it into `buffer'"
  (interactive "rp")
  (setq var-defination (buffer-substring-no-properties start end))
  (let* ((tmp_str "")
         (var-name "")
         (var-type "")
         (counter 0)
         (struct-name "")
         (header-str ""))
    (defun iter (pos)
      (setq counter (+ counter 1))
      (message (format "Counter: %d, pos: %d"
                       counter pos))
      (if (string-match r_name var-defination pos)
          (progn
            (message "A")
            (setq struct-name
                  (match-string 2 var-defination))
            ;; (setq struct-name (caar (semantic-parse-region start end)))
            (setq header-str
                  (format yyc/dot-head struct-name struct-name))
            (setq tmp_str
                  (format yyc/dot-node-head struct-name struct-name))
            (iter (match-end 0)))
        (if (string-match r_attr_str var-defination pos)
            (progn
              (message "B")
              (setq var-type
                    (match-string 1 var-defination))
              (setq var-name
                    (match-string 2 var-defination))
              (setq tmp_str
                    (concat tmp_str
                            (format attr_str counter var-type var-name)))
              (iter (match-end 0)))
          nil)))
    (save-excursion
      (iter 0)
      (set-buffer (get-buffer-create "tmp.dot"))
      ;;(graphviz-dot-mode)
      (setq pos (point-max))
      (insert  header-str tmp_str )
      (goto-char (point-max))
      (delete-char -1)
      (insert "<f999>\\"yyc/dot-node-tail yyc/dot-tail)
      )
    (if (one-window-p)
        (split-window-vertically))
    (switch-to-buffer-other-window "tmp.dot")
    (goto-char (point-min))
    )
  (message "Finished, please see *tmp.dot* buffer.")
  )
#+END_SRC

使用方法
用起来很简单：找到一个 C 代码，标记整个 struct 定义，然后M-x 输入： yyc/datastruct-to-dot 即可。命令执行完毕后，会打开一个新的 tmp.dot buffer，其中包含了用于绘制该 struct 的代码。前面也提到了，这生成的仅仅是个 subgraph，需要将这个 subgraph 添加到真正的 graph 下，才能生成图像。我通过 autoinsert 来自动创建用于放置 subgraph 的 graph 。

*** autoinsert配置
autoinsert 是 Emacs 自带的功能，稍加配置即可使用：

#+BEGIN_SRC emacs-lisp
;; ************** Autoinsert templates *****************
(use-package autoinsert
  :defer t)

(setq auto-insert-mode t)  ;;; Adds hook to find-files-hook
(setq auto-insert-directory "~/.emacs.d/templates/auto-insert/")
(setq auto-insert 'other)
(setq auto-insert-query nil)
 
;; auto-insert stuff
(add-hook 'find-file-hooks 'auto-insert)
(setq auto-insert-alist
      '(
        ("\\.cpp$" . ["insert.cpp" auto-update-c-source-file])
        ("\\.h$"   . ["header.h" auto-update-header-file])
        ("\\.c$" . ["insert.c" auto-update-c-source-file])
        ("\\.org$" . ["insert.org" auto-update-defaults])
        ("\\.sh$" . ["insert.sh" auto-update-defaults])
        ("\\.lisp$" . ["insert.lisp" auto-update-defaults])
        ("\\.el$" . ["insert.el" auto-update-defaults])
        ("\\.dot$" . ["insert.dot" auto-update-defaults])
        ("\\.erl$" . ["insert.err" auto-update-defaults])
        ("\\.py$" . ["insert.py" auto-update-defaults])
        ("\\.tex$" . ["insert.tex" auto-update-defaults])
        ("\\.html$" . ["insert.html" auto-update-defaults])
        ("\\.devhelp2$" . ["insert.devhelp2" auto-update-defaults])
        ("\\.ebuild$" . ["insert.ebuild" auto-update-defaults])
        ("\\.sh$" . ["insert.sh" auto-update-defaults])
        ("Doxyfile$" . ["insert.doxyfile" auto-update-defaults])
        ))
 
;; function replaces the string '@@@' by the current file
;; name. You could use a similar approach to insert name and date into
;; your file.
(defun auto-update-header-file ()
  (save-excursion
    (while (search-forward "@@@" nil t)
      (save-restriction
        (narrow-to-region (match-beginning 0) (match-end 0))
        (replace-match (upcase (file-name-nondirectory buffer-file-name)))
        (subst-char-in-region (point-min) (point-max) ?. ?_)
        ))))
 
(defun insert-today ()
  "Insert today's date into buffer"
  (interactive)
  (insert (format-time-string "%m-%e-%Y" (current-time))))
 
(defun auto-update-c-source-file ()
  (save-excursion
    ;; Replace HHHH with file name sans suffix
    (while (search-forward "HHHH" nil t)
      (save-restriction
        (narrow-to-region (match-beginning 0) (match-end 0))
        (replace-match (concat (file-name-sans-extension (file-name-nondirectory buffer-file-name)) ".h") t)
        )))

  (save-excursion
    ;; Replace @@@ with file name
    (while (search-forward "@@@" nil t)
      (save-restriction
        (narrow-to-region (match-beginning 0) (match-end 0))
        (replace-match (file-name-nondirectory buffer-file-name))
        )))
  (save-excursion
    ;; replace DDDD with today's date
    (while (search-forward "DDDD" nil t)
      (save-restriction
        (narrow-to-region (match-beginning 0) (match-end 0))
        (replace-match "")
        (insert-today)
        ))))
 
(defun auto-replace-file-name ()
  (save-excursion
    ;; Replace @@@ with file name
    (while (search-forward "(>>FILE<<)" nil t)
      (save-restriction
        (narrow-to-region (match-beginning 0) (match-end 0))
        (replace-match (file-name-nondirectory buffer-file-name) t)
        ))
    ))
 
(defun auto-update-defaults ()
  (auto-replace-file-name)
  (auto-replace-file-name-no-ext)
  (auto-replace-date-time))
 
(defun auto-replace-file-name-no-ext ()
  (save-excursion
    ;; Replace @@@ with file name
    (while (search-forward "(>>FILE_NO_EXT<<)" nil t)
      (save-restriction
        (narrow-to-region (match-beginning 0) (match-end 0))
        (replace-match (file-name-sans-extension (file-name-nondirectory buffer-file-name)) t)
        ))))
 
(defun auto-replace-date-time ()
  (save-excursion
    (while (search-forward "(>>DATE<<)" nil t)
      (save-restriction
        (narrow-to-region (match-beginning 0) (match-end 0))
        (replace-match "" t)
        (insert-today)
        ))))
#+END_SRC

模板文件存放于 “~/.emacs.d/templates/auto-insert/” 中，其中， insert.dot 的内容如下：

// $Id: (>>FILE<<), (>>DATE<<)
digraph Name {
    node [shape=record fontsize=12 fontname=Courier style=filled];
    edge[color=blue];
    rankdir=LR;

// XXX: place to put subgraph
}

*** 用法示例
一个简单的使用示例，有如下步骤：

1. 打开一个 C 文件

   如内核代码中的 drivers/usb/storage/usb.h

2. 打开一个 dot 文件(/tmp/usb.dot)

   auto-insert 会自动插入一些文件内容.

3. 选中 struct us_data 的定义，并执行 yyc/datastruct-to-dot。

   执行完成后， us_data 的数据填写到了 tmp.dot 中，将该 buffer 中的所有内容 kill 掉，并 yank 到 usb.dot 中 XXX 这一行的下面。此时，保存 sub.dot ， 并按下快捷键 : C-cc ， 然后按下 Enter ， 就会自动编译。然后再按下 C-cp 就可以在另外一个 buffer 中预览它了。

   其实到这里，一个 C 语言的 struct 数据结构就已经被画出来了，后面的两个步骤，是为了介绍怎样将多个数据结构联系起来。

4. 添加其他的subgraph 

   我们可以继续添加其他的subgraph， 例如 struct usb_ctrlrequest *cr ，以及 struct usb_sg_request， 并全部做为 subgraph 添加到 usb.dot 中。

5. 为 subgraph 建立关联

   很简单，通过 “->” 画两条线就可以了。

*** semantic [2019-01-08 周二 20:47:56]
https://segmentfault.com/a/1190000004910645?utm_source=tuicool&utm_medium=referral [译] Emacs Lisp 速成

;; 这样写不太好看
;; (if (eq function-pointer t)
;;     (setq str (var-str str index type))
;;   (setq str (concat str (format "%s " (semantic-tag-name type)))))))

#+BEGIN_SRC emacs-lisp
(defun albert/datastruct-member (tag)
  "parse tag generated by semantic-parse-region."

  (defun fp-str (str ftag)
    "function pointer args to str. 函数指针参数的处理.如ngx_tcp_module_t里的函数指针"
    (cond
      ((null ftag) "")
      ((cond
         ((semantic-tag-p ftag)
           (let* ((name (semantic-tag-name ftag))
                  (type (semantic-tag-get-attribute ftag :type))
                  (pointer (semantic-tag-get-attribute ftag :pointer)))
             (cond
               ((atom type) (setq str (concat str (format "%s " type))))
               ((semantic-tag-p type) 
                 (setq str (concat str (format "%s " (semantic-tag-name type))))))
 
             (if (numberp pointer)
               (setq str (concat str (make-string pointer ?*))))

             (setq str (concat str (format "%s, " name)))
             ))
         (t (setq str (concat (fp-str str (car ftag)) (fp-str str (cdr ftag)))))
         ))
    ))

  (defun var-str (str index vtag)
    (setq str (format "    <f%d>" index))
    (cond
      ((null vtag) "")
      ((cond
         ((semantic-tag-p vtag)
           (let* ((name (semantic-tag-name vtag))
                  (type (semantic-tag-get-attribute vtag :type))
                  ;;(function-pointer (semantic-tag-get-attribute vtag :function-pointer))
                  (pointer (semantic-tag-get-attribute vtag :pointer)))
             (cond
               ((atom type) (setq str (concat str (format "%s " type))))
               ;; 函数指针要单独处理,如ngx_tcp_module_t里的函数指针
               ((semantic-tag-p type) 
                 (setq str (concat str (format "%s " (semantic-tag-name type))))))
 
             (if (numberp pointer)
               (setq str (concat str (make-string pointer ?*))))

             (if (semantic-tag-get-attribute vtag :function-pointer)
                 (let* ((tmp (fp-str "" (semantic-tag-components vtag)))
                        (args (substring tmp 0 (- (length tmp) 2))))
                       (setq str (format "%s(*%s)(%s) \\l|\\\n" str name args)))
               (concat str (format "%s \\l|\\\n" name)))
             ))
       (t (concat (var-str str (+ index 1) (car vtag)) (var-str str (+ index 1) (cdr vtag))))
         ))
      ))
  (var-str "" 0 tag))
  
(defun albert/datastruct-dot-head (tag)
  "datastruct name to dot head."
  (let ((name (semantic-tag-name tag)))
    (format "subgraph cluster_%s {
  node [shape=record fontsize=12 fontname=Courier style=filled];
  color=lightgray;
  style=filled;
  label = \"Struct %s\";
  edge[color=\"#2e3436\"];
  node_%s [shape=record label=\"\n" name name name)))
  
(defun albert/datastruct-dot-end (str)
  "datastruct to dot end string. 去掉最后一个字段的\l|\n"
  (concat (substring str 0 (- (length str) 3)) "\"];
}\n"))

(defun albert/semantic-lex-buffer (start end)
  "parse c datastruct definition using semantic and insert it into `buffer'"
  (interactive "rp")
  (message "start=%d, end=%d" start end)
  (let* ((tag (car (semantic-parse-region start end)))
         (members (plist-get (semantic-tag-class (semantic-tag-get-attribute tag :typedef)) :members)))
    ;; (message "%s\n" tag)
    ;;(message "%s" (albert/datastruct-dot-head tag))
    ;; (message "%s" (albert/datastruct-member (semantic-tag-components tag)))
    (let* ((body (albert/datastruct-member (semantic-tag-components tag)))
           (dot_str (albert/datastruct-dot-end body)))
      ;;(message "%s" (albert/datastruct-dot-end body))
      (save-excursion
        ;;(iter 0)
        (set-buffer (get-buffer-create "tmp.dot"))
        ;;(graphviz-dot-mode)
        (setq pos (point-max))
        (insert (albert/datastruct-dot-head tag) 
                dot_str)
        (goto-char (point-max))
        (delete-char -1)
      )

      (if (one-window-p)
        (split-window-vertically))

      (switch-to-buffer-other-window "tmp.dot")
      (goto-char (point-min))
    )))

     ;; (plist-get (nthcdr 2 (semantic-tag-get-attribute tag :typedef)) :members))

  ;; (message (semantic-parse-region start end 1)))
  ;; (message (semantic-c-lexer start end 1)))
  ;; (message (semantic-lex-buffer)))
  ;;(semantic-lex start end 1))
#+END_SRC
** magit
[2014-09-11 10:22:26] disable emacs自带的vc，用 *process monitor* 看，vc每次打开都会把支持的版本管理都查一遍，会比较慢。
但是去掉了以后，magit没法在status bar上显示文件在哪个branch上了。哎。

process monitor在用了vpn后会导致机器hang。

把vc disable后会快不少，还是去了吧。

#+BEGIN_SRC lisp
;; (custom-set-variables
;; '(vc-handled-backends (quote (Git))))

;; disable default vc
;(setq vc-handled-backends nil)
#+end_src

[2014-09-11 14:25:06] 即使更新到了0908的magit，仍然发现有多次调用git.exe的情况， *magit-status* 还是慢
把git的path设置到最前面，貌似速度也没快多少，最多0.001s吧。

;;(if (eq system-type 'windows-nt)
;;    (progn
;;      (setq exec-path (add-to-list 'exec-path "C:/Program Files/Git/bin"))
;;      (setenv "PATH" (concat "C:\\Program Files\\Git\\bin;" (getenv "PATH")))))

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :defer t
  :config
    (progn
      (setq magit-last-seen-setup-instructions "1.4.0")))
#+end_src

** neotree - 不用了 [2019-05-27 周一 16:05:25]

#+BEGIN_SRC lisp
(add-hook 'neotree-mode-hook
            (lambda ()
              (define-key evil-normal-state-local-map (kbd "TAB") 'neotree-enter)
              (define-key evil-normal-state-local-map (kbd "SPC") 'neotree-enter)
              (define-key evil-normal-state-local-map (kbd "q") 'neotree-hide)
              (define-key evil-normal-state-local-map (kbd "RET") 'neotree-enter)))
#+END_SRC
** tramp on windows [2018-12-28 周五 11:14:58]

+ new session
  /plink:user@host:/path/to/your/file/on/server

+ saved session
  /plinkx:sessname:/path/to/your/file/on/server
  
+ 不需要设置 tramp-shell-prompt-pattern 和 tramp-password-end-of-line 。
+ plink要在PATH里有。

[2019-06-08 周六 01:44:30] tramp在windows上没法用，连虚机都能感觉到实在是太卡了。
#+BEGIN_SRC lisp
(use-package tramp
  :defer t
  :config
    (progn
      (setq exec-path (cons "E:/tools/putty" exec-path))
      ;; (setq tramp-password-end-of-line "\r\n")
      ;; (setq tramp-shell-prompt-pattern "^[ $]# +")
      (setq tramp-ssh-controlmaster-options "-o ControlMaster=auto -o ControlPath='tramp.%%C' -o ControlPersist=no")
      (setq tramp-default-method "plink")))
#+END_SRC
** xah-find [2018-09-29 周六 22:09:48]
http://ergoemacs.org/emacs/elisp-xah-find-text.html

1. evil mode下按tab和enter都不能跳转到文件对应的地方，只能用鼠标，除非是emacs mode下。
2. 不知道是怎么找的扩展名，如果打开一个 *.te的文件，默认扩展名就是 *.te，改改?

#+BEGIN_SRC emacs-lisp
(use-package xah-find
  :ensure t
  :defer t)
#+END_SRC

** ggtags [2019-01-01 周二 00:32:00]

| key     | function              | 说明                       |
|---------+-----------------------+----------------------------|
| M-.     | ggtags-find-tag-dwim  | C-] 在evil-mode中 无法bind |
| M-,/C-T | xref-pop-marker-stack | C-T bind的是 pop-tag-mark  |
| M-]     | ggtags-find-reference | 查询调用了tag的reference   |

#+BEGIN_SRC emacs-lisp
(use-package ggtags
  :ensure t
  :defer t)

(add-hook 'c-mode-common-hook
  (lambda ()
    (when (derived-mode-p 'c-mode 'c++-mode 'java-mode 'asm-mode)
      (progn
        ;; (linum-mode 1)
        ;; (flycheck-mode 1)
        (ggtags-mode 1)))))
#+END_SRC

*** global [2019-06-11 周二 17:11:26]
GNU Global具有强大的跨平台能力，无论是在Linux还是在BSD系统还是Windows都可以使用。GNU Global具有以下功能：

+ 内置6种语法分析程序（定义和引用）C，C++，Yacc，Java，PHP4和汇编
+ 通过ctags的语法解析插件可以支持25中语言（定义和引用）Awk, Dos batch, COBOL, C, C++, C#, Erlang,Fortran, Java, JavaScript, Lisp, Lua, Pascal, Perl, PHP, Python, Ruby, Matlab, OCaml, Scheme, Tcl, TeX, Verilog, Vhdl and Vim

GNU Global使用
命令行下使用GLOBAL，在开始使用前可以看一下FAQ
#+BEGIN_SRC sh
$less /your/gtags/path/FAQ
#+END_SRC

首先我们需要使用gtags命令来产生代码树的tag文件，例如当我想要浏览内核代码时，只需要执行以下命令
#+BEGIN_SRC sh
$cd ~/code/kernel/
$gtags -v
#+END_SRC

执行完之后会发现，在kernel目录下产生了3个tag文件分别是GPATH，GRTAGS，GTAGS，GTAGS是定义的数据库，GRTAGS是引用的数据库，GPATH是路径的数据库。

** GDB [2019-01-11 周五 21:23:16]

这是在Linux上用，windows不需要配置。
=M-x gdb=

+ file 打开执行文件
+ l (list): 从第一行开始列出源码，默认10行。
+ b (break):  b <行号> ， b <函数名>
+ r (run): 开始运行调试器，或重新开始运行调试器
+ c (continue): 继续运行到下一个断点，或运行到程序结束
+ clear : clear <行号> ，删除特定行的断点
+ d (delete): d <断点编号>，删除特定编号的断点
+ n (next): 单步执行下一行，如果本行有函数调用，不进入函数
+ s (step): 单步执行下一行，如果本行有函数调用，进入函数
+ until： 结束当前循环
+ p (print): p <变量名>， 显示变量内容
+ whatis： whatis<变量名>，显示变量类型
+ info： info b， 显示断点信息。 info r 显示寄存器信息。 info local 显示当前函数中的局部变量信息。info prog 显示被调试程序的执行状态。
+ p *array@len : 打印一维数组
+ p **array@len : 打印二维数组
+ quit： 退出调试器。

emacs默认的gdb-many-windows有6个调试窗口，有些不常用的，比如断点信息窗等，简化为4个。其实都有用。不改了。

#+BEGIN_SRC lisp
;; set gdb multi-windows when open
(setq gdb-many-windows t)

;; customize the gdb multi-windows
;; 默认的就好用
;; (defadvice gdb-setup-windows (after my-setup-gdb-windows activate)
;;   "My GDB UI"
;;   (gdb-get-buffer-create 'gdb-stack-buffer)
;;   (set-window-dedicated-p (selected-window) nil)
;;   (switch-to-buffer gud-comint-buffer)
;;   (delete-other-windows)
;;   (let ((win0 (selected-window))
;;         (win1 (split-window nil nil 'left))  ;; code and output
;;         (win2 (split-window-below (/ (* (window-height) 3) 4)))  ;; stack
;;         )
;;     (select-window win2)
;;     (gdb-set-window-buffer (gdb-stack-buffer-name))
;;     (select-window win1)
;;     (set-window-buffer
;;      win1
;;      (if gud-last-last-frame
;;          (gud-find-file (car gud-last-last-frame))
;;        (if gdb-main-file
;;            (gud-find-file gdb-main-file)
;;          ;; Put buffer list in window if we
;;          ;; can't find a source file.
;;          (list-buffers-noselect))))
;;     (setq gdb-source-window (selected-window))
;;     (let ((win3 (split-window nil (/ (* (window-height) 3) 4))))  ;; io
;;       (gdb-set-window-buffer (gdb-get-buffer-create 'gdb-inferior-io) nil win3))
;;     (select-window win0)
;;     ))
#+END_SRC
** undotree

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :defer t
  :diminish undo-tree-mode
  :config
    (progn
      (global-undo-tree-mode)
      (setq undo-tree-visualizer-timestamps t)
      (setq undo-tree-visualizer-diff t)))

(defalias 'redo 'undo-tree-redo)
;;(global-set-key (kbd "C-z") 'undo) ; [Ctrl+z]
;;(global-set-key (kbd "C-S-z") 'redo) ; [Ctrl+Shift+z];  Mac style
;;(global-set-key (kbd "C-y") 'redo) ; [Ctrl+y]; Microsoft Windows style
(global-set-key (kbd "C-r") 'redo) ; [Ctrl+r]; VIM style
#+END_SRC

* org mode
http://doc.norang.ca/org-mode.html

** 4 Getting Started
*** 4.2 Org-Mode Setup

参考 doom-emacs的配置文件 =.emacs.d.doom/modules/lang/org/config.el= ，只加载部分org-mode的modules，不需要邮件、irc。

#+BEGIN_SRC lisp
;;; Albert_org_config.el -*- lexical-binding: t; -*-
#+END_SRC

用了org-babel，org-modules要在init.el中(require 'org)之前设置。
#+BEGIN_SRC lisp
;; (setq org-modules '(org-w3m org-docview org-info))

;; (defvar org-modules
;;   '(;; org-w3m
;;     ;; org-bbdb
;;     ;; org-bibtex
;;     org-docview
;;     ;; org-gnus
;;     org-info
;;     ;; org-irc
;;     ;; org-mhe
;;     ;; org-rmail
;;     ))
#+END_SRC

org-mode is the default mode for .org, .org_archive, and .txt files.
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.\\(org\\|org_archive\\|txt\\)$" . org-mode))

;; Standard key bindings
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
(global-set-key "\C-cb" 'org-iswitchb)
(setq org-log-done t)
#+END_SRC

*** 4.6 Key bindings

Custom Key Bindings

常用的列在前面。
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<f12>") 'org-agenda)
(global-set-key (kbd "<f3>") 'bh/org-todo)
(global-set-key (kbd "<S-f3>") 'bh/widen)
(global-set-key (kbd "<f7>") 'bh/set-truncate-lines)
(global-set-key (kbd "<f8>") 'org-cycle-agenda-files)
(global-set-key (kbd "<f9> <f9>") 'bh/show-org-agenda)
;; (global-set-key (kbd "<f9> b") 'bbdb)
;; (global-set-key (kbd "<f9> c") 'calendar)
(global-set-key (kbd "<f9> f") 'boxquote-insert-file)
;;(global-set-key (kbd "<f9> g") 'gnus)
(global-set-key (kbd "<f9> h") 'bh/hide-other)
(global-set-key (kbd "<f9> n") 'bh/toggle-next-task-display)
(global-set-key (kbd "<f9> w") 'widen)

(global-set-key (kbd "<f9> I") 'bh/punch-in)
(global-set-key (kbd "<f9> O") 'bh/punch-out)

;; (global-set-key (kbd "<f9> o") 'bh/make-org-scratch)

(global-set-key (kbd "<f9> r") 'boxquote-region)
(global-set-key (kbd "<f9> s") 'bh/switch-to-scratch)

(global-set-key (kbd "<f9> t") 'bh/insert-inactive-timestamp)
(global-set-key (kbd "<f9> T") 'bh/toggle-insert-inactive-timestamp)

(global-set-key (kbd "<f9> v") 'visible-mode)
(global-set-key (kbd "<f9> l") 'org-toggle-link-display)
(global-set-key (kbd "<f9> SPC") 'bh/clock-in-last-task)
(global-set-key (kbd "C-<f9>") 'previous-buffer)
(global-set-key (kbd "M-<f9>") 'org-toggle-inline-images)
(global-set-key (kbd "C-x n r") 'narrow-to-region)
(global-set-key (kbd "C-<f10>") 'next-buffer)
(global-set-key (kbd "<f11>") 'org-clock-goto)
(global-set-key (kbd "C-<f11>") 'org-clock-in)
(global-set-key (kbd "C-s-<f12>") 'bh/save-then-publish)
(global-set-key (kbd "C-c c") 'org-capture)

(setq org-agenda-files (list "~/org"))

;; '(org-refile-targets (quote (("newgtd.org" :maxlevel . 1) 
;;                               ("albert.org" :level . 2))))
#+END_SRC

** 6 Adding New Tasks Quickly with Org Capture
*** 6.1 Capture Templates
When a new task needs to be added I categorize it into one of a few things:
对于一个新增加的task，我把它分为下面几类:

- A phone call (p) 电话
- A meeting (m) 会议
- An email I need to respond to (r) 需要回复的email
- A new task (t) 新的task
- A new note (n) 新的note
- An interruption (j) 中断
- A new habit (h) 新的habit

and pick the appropriate capture task.

Here is my setup for org-capture

#+BEGIN_SRC emacs-lisp
(setq org-directory "~/org")
(setq org-default-notes-file "~/org/refile.org")

(defun bh/hide-other ()
  (interactive)
  (save-excursion
    (org-back-to-heading 'invisible-ok)
    (hide-other)
    (org-cycle)
    (org-cycle)
    (org-cycle)))

(defun bh/set-truncate-lines ()
  "Toggle value of truncate-lines and refresh window display."
  (interactive)
  (setq truncate-lines (not truncate-lines))
  ;; now refresh window display (an idiom from simple.el):
  (save-excursion
    (set-window-start (selected-window)
                      (window-start (selected-window)))))

;; (defun bh/make-org-scratch ()
;;   (interactive)
;;   (find-file "/tmp/publish/scratch.org")
;;   (gnus-make-directory "/tmp/publish"))

(defun bh/switch-to-scratch ()
  (interactive)
  (switch-to-buffer "*scratch*"))

;; I use C-c c to start capture mode
(global-set-key (kbd "C-c c") 'org-capture)

;; Capture templates for: TODO tasks, Notes, appointments, phone calls, meetings, and org-protocol
(setq org-capture-templates
      (quote (("t" "todo" entry (file "~/org/refile.org")
               "* TODO %?\n%U\n%a\n" :clock-in t :clock-resume t)
              ("r" "respond" entry (file "~/org/refile.org")
               "* NEXT Respond to %:from on %:subject\nSCHEDULED: %t\n%U\n%a\n" :clock-in t :clock-resume t :immediate-finish t)
              ("n" "note" entry (file "~/org/refile.org")
               "* %? :NOTE:\n%U\n%a\n" :clock-in t :clock-resume t)
              ("j" "Journal" entry (file+datetree "~/org/diary.org")
               "* %?\n%U\n" :clock-in t :clock-resume t)
              ("w" "org-protocol" entry (file "~/org/refile.org")
               "* TODO Review %c\n%U\n" :immediate-finish t)
              ("m" "Meeting" entry (file "~/org/refile.org")
               "* MEETING with %? :MEETING:\n%U" :clock-in t :clock-resume t)
              ("p" "Phone call" entry (file "~/org/refile.org")
               "* PHONE %? :PHONE:\n%U" :clock-in t :clock-resume t)
              ("h" "Habit" entry (file "~/org/refile.org")
               "* NEXT %?\n%U\n%a\nSCHEDULED: %(format-time-string \"<%Y-%m-%d %a .+1d/3d>\")\n:PROPERTIES:\n:STYLE: habit\n:REPEAT_TO_STATE: NEXT\n:END:\n"))))
#+END_SRC

** 7 Refiling Tasks
*** 7.1 Refile Setup

#+BEGIN_SRC emacs-lisp
; Targets include this file and any file contributing to the agenda - up to 9 levels deep
(setq org-refile-targets (quote ((nil :maxlevel . 6)
                                 (org-agenda-files :maxlevel . 6))))

; Use full outline paths for refile targets - we file directly with IDO
(setq org-refile-use-outline-path t)

; Targets complete directly with IDO
(setq org-outline-path-complete-in-steps nil)

; Allow refile to create parent tasks with confirmation
(setq org-refile-allow-creating-parent-nodes (quote confirm))

;; [2018-12-01 周六 16:35:26] 和helm有冲突，直接用helm

; Use IDO for both buffer and file completion and ido-everywhere to t
;;(setq org-completion-use-ido t)
;; (setq ido-everywhere t)
;; (setq ido-max-directory-size 100000)
;; (ido-mode (quote both))
; Use the current window when visiting files and buffers with ido
;; (setq ido-default-file-method 'selected-window)
;; (setq ido-default-buffer-method 'selected-window)

; Use the current window for indirect buffer display
(setq org-indirect-buffer-display 'current-window)

;;;; Refile settings
; Exclude DONE state tasks from refile targets
(defun bh/verify-refile-target ()
  "Exclude todo keywords with a done state from refile targets"
  (not (member (nth 2 (org-heading-components)) org-done-keywords)))

(setq org-refile-target-verify-function 'bh/verify-refile-target)
#+END_SRC

** 8 Custom agenda views - 定制agenda views
*** 8.1 Setup

#+BEGIN_SRC emacs-lisp
;; Do not dim blocked tasks
(setq org-agenda-dim-blocked-tasks nil)

;; Compact the block agenda view
(setq org-agenda-compact-blocks t)

;; Custom agenda command definitions
(setq org-agenda-custom-commands
      (quote (("N" "Notes" tags "NOTE"
               ((org-agenda-overriding-header "Notes")
                (org-tags-match-list-sublevels t)))
              ("h" "Habits" tags-todo "STYLE=\"habit\""
               ((org-agenda-overriding-header "Habits")
                (org-agenda-sorting-strategy
                 '(todo-state-down effort-up category-keep))))
              (" " "Agenda"
               ((agenda "" nil)
                (tags "REFILE"
                      ((org-agenda-overriding-header "Tasks to Refile")
                       (org-tags-match-list-sublevels nil)))
                (tags-todo "-CANCELLED/!"
                           ((org-agenda-overriding-header "Stuck Projects")
                            (org-agenda-skip-function 'bh/skip-non-stuck-projects)
                            (org-agenda-sorting-strategy
                             '(category-keep))))
                (tags-todo "-HOLD-CANCELLED/!"
                           ((org-agenda-overriding-header "Projects")
                            (org-agenda-skip-function 'bh/skip-non-projects)
                            (org-tags-match-list-sublevels 'indented)
                            (org-agenda-sorting-strategy
                             '(category-keep))))
                (tags-todo "-CANCELLED/!NEXT"
                           ((org-agenda-overriding-header (concat "Project Next Tasks"
                                                                  (if bh/hide-scheduled-and-waiting-next-tasks
                                                                      ""
                                                                    " (including WAITING and SCHEDULED tasks)")))
                            (org-agenda-skip-function 'bh/skip-projects-and-habits-and-single-tasks)
                            (org-tags-match-list-sublevels t)
                            (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-sorting-strategy
                             '(todo-state-down effort-up category-keep))))
                (tags-todo "-REFILE-CANCELLED-WAITING-HOLD/!"
                           ((org-agenda-overriding-header (concat "Project Subtasks"
                                                                  (if bh/hide-scheduled-and-waiting-next-tasks
                                                                      ""
                                                                    " (including WAITING and SCHEDULED tasks)")))
                            (org-agenda-skip-function 'bh/skip-non-project-tasks)
                            (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-sorting-strategy
                             '(category-keep))))
                (tags-todo "-REFILE-CANCELLED-WAITING-HOLD/!"
                           ((org-agenda-overriding-header (concat "Standalone Tasks"
                                                                  (if bh/hide-scheduled-and-waiting-next-tasks
                                                                      ""
                                                                    " (including WAITING and SCHEDULED tasks)")))
                            (org-agenda-skip-function 'bh/skip-project-tasks)
                            (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-sorting-strategy
                             '(category-keep))))
                (tags-todo "-CANCELLED+WAITING|HOLD/!"
                           ((org-agenda-overriding-header "Waiting and Postponed Tasks")
                            (org-agenda-skip-function 'bh/skip-stuck-projects)
                            (org-tags-match-list-sublevels nil)
                            (org-agenda-todo-ignore-scheduled t)
                            (org-agenda-todo-ignore-deadlines t)))
                (tags "-REFILE/"
                      ((org-agenda-overriding-header "Tasks to Archive")
                       (org-agenda-skip-function 'bh/skip-non-archivable-tasks)
                       (org-tags-match-list-sublevels nil))))
               nil))))

;; Remove empty LOGBOOK drawers on clock out
(defun bh/remove-empty-drawer-on-clock-out ()
  (interactive)
  (save-excursion
    (beginning-of-line 0)
    (org-remove-empty-drawer-at (point))))

(add-hook 'org-clock-out-hook 'bh/remove-empty-drawer-on-clock-out 'append)
#+END_SRC

My block agenda view looks like this when not narrowed to a project. This shows top-level projects and =NEXT= tasks but hides the project details since we are not focused on any particular project.

因为不关注特定的project，只显示隐藏了项目细节的顶级项目和 =NEXT= 的task。

After selecting a project (with =P= on any task in the agenda) the block agenda changes to show the project and any subprojects in the Projects section.  

Tasks show project-related tasks that are hidden when not narrowed to a project.

在选择了一个项目后(在agenda中的任何task上按 =P= )，会改变阻塞的agenda，在project选择中显示project和subproject。

This makes it easy to focus on the task at hand.

这样会容易聚焦到正在做的task。

I generally work top-down on the agenda.  Things with deadlines and
scheduled dates (planned to work on today or earlier) show up in the
agenda at the top.

通常从上到下处理agenda。有deadline和计划日期的事情（今天或者以前计划的工作）在agenda的顶部显示出来。

My day goes generally like this:

一天的工作流程通常如下：

- Punch in (this starts the clock on the default task)
  打卡（在默认task上开始计时）

- Look at the agenda and make a mental note of anything important to deal with today
  查看agenda，然后思考一下今天有什么重要的事情

- Read email and news
  看邮件和新闻

  - create notes, and tasks for things that need responses with org-capture
    通过 =org-capture= 创建建需要反馈的note和task

- Check refile tasks and respond to emails
  检查refile的task和回邮件

- Look at my agenda and work on important tasks for today
  查看agenda并处理今天的重要task

  - Clock it in
    打卡计时

  - Work on it until it is =DONE= or it gets interrupted
    处理task，直到完成 =DONE= 或被中断

- Work on tasks
  处理task

- Make journal entries (=C-c c j=) for interruptions
  给中断建一个journal entry（ =C-c c j= ）

- Punch out for lunch and punch back in after lunch
  午餐时打卡签退，吃完后在打卡签到

- work on more tasks
  继续做其他的task

- Refile tasks to empty the list
  把task refile到一个空list

  - Tag tasks to be refiled with =m= collecting all tasks for the same target
    按 =m= 给相同target的所有task打个tag

  - Bulk refile the tasks to the target location with =B r=
    按 =B r= 批量refile task到目标文件

  - Repeat (or refile individually with =C-c C-w=) until all refile tasks are gone
    重复上述动作(或者按 =C-c C-w= 一个一个的refile)，直到所有的task都refile了

- Mark habits done today as DONE
  给所有今天完成的habit标记为 DONE

- Punch out at the end of the work day
  一个工作结束后打卡签退
*** 8.2 What do I work on next? 接下来干什么呢？
:PROPERTIES:
:CUSTOM_ID: WhatDoIWorkOnNext
:END:

Start with deadlines and tasks scheduled today or earlier from the
daily agenda view.  Then move on to tasks in the =Next Tasks= list in
the block agenda view.  I tend to schedule current projects to 'today'
when I start work on them and they sit on my daily agenda reminding me
that they need to be completed.  I normally only schedule one or two
projects to the daily agenda and unschedule things that are no longer
important and don't deserve my attention today.

开始完成一个今天计划要做的或者deadline是今天的task，或者先前的daily agenda view中的task。然后转到在block agenda view中的 =Next Tasks= 列表中的task。

When I look for a new task to work on I generally hit =F12 SPC= to get
the block agenda and follow this order:
当我要找一个新的task去做时，一般按 =F12 SPC= 来看block agenda，用下面的顺序：

- Pick something off today's agenda
  在今天的agenda中选择一个

  - deadline for today (do this first - it's not late yet)
    deadline是今天的（首先做这个 - 现在做还不晚）

  - deadline in the past (it's already late)
    deadline是以前的（反正已经晚了）

  - a scheduled task for today (it's supposed to be done today)
    今天计划做的task（需要在今天完成）
    
  - a scheduled task that is still on the agenda
    agenda中还有的计划的task

  - deadline that is coming up soon
    deadline快要到的task

- pick a NEXT task
  选择一个tag标记为 =NEXT= 的task

- If you run out of items to work on look for a NEXT task in the current context
  如果当前的NEXT的task都做完了

  pick a task from the Tasks list of the current project.
  从当前project的task列表选一个task
**** Why keep it all on the =NEXT= list? 为什么把task都放到 =NEXT= list中
:PROPERTIES:
:CUSTOM_ID: CustomAgendaViewsNextList
:END:

I've moved to a more GTD way of doing things.  Now I just use a =NEXT=
list.  Only projects get tasks with =NEXT= keywords since stuck projects
initiate the need for marking or creating =NEXT= tasks.  A =NEXT= task
is something that is available to work on /now/, it is the next
logical step in some project.

I used to have a special keyword =ONGOING= for things that I do a lot
and want to clock but never really start/end.  I had a special agenda
view for =ONGOING= tasks that I would pull up to easily find the thing
I want to clock.

Since then I've moved away from using the =ONGOING= todo keyword.
Having an agenda view that shows =NEXT= tasks makes it easy to pick
the thing to clock - and I don't have to remember if I need to look in
the =ONGOING= list or the =NEXT= list when looking for the task to
clock-in.  The =NEXT= list is basically 'what is current' - any task
that moves a project forward.  I want to find the thing to work on as
fast as I can and actually do work on it - not spend time hunting
through my org files for the task that needs to be clocked-in.

现在不再用 =ONGOING= todo关键字了。由于可显示 =NEXT= task的agent view会容易选择一项工作来计时，在查找 =ONGOING= 或者 =NEXT= task进行打卡计时的时候也不用记住他。=NEXT= list就是当前的task列表，任何让project继续进行的task都在里面。尽快找到实际要做的工作去做，不要在一大堆org文件中浪费时间去找下一个需要打卡计时的task。

To drop a task off the =NEXT= list simply move it back to the =TODO=
state.
把task的状态从 =NEXT= 改为 =TODO= 就可以从 =NEXT= 给去掉。

*** 8.3 Reading email, newsgroups, and conversations on IRC 看邮件、新闻组和聊天
:PROPERTIES:
:CUSTOM_ID: ReadingMailNewsIRC
:END:

When reading email, newsgroups, and conversations on IRC I just let
the default task (normally =** Organization=) clock the time I spend on
these tasks.  To read email I go to Gnus and read everything in my
inboxes.  If there are emails that require a response I use
org-capture to create a new task with a heading of 'Respond to <user>'
for each one.  This automatically links to the email in the task and
makes it easy to find later.  Some emails are quick to respond to and
some take research and a significant amount of time to complete.  I
clock each one in it's own task just in case I need that clocked time
later.  The capture template for Repond To tasks is now scheduled for
today so I can refile the task to the appropriate org file without
losing the task for a week.

看邮件、新闻组和聊天的时候，我会让默认task在计时状态。如果有需要反馈的邮件，我会用 org-capture 创建一个新的任务，标题是 '给某人的反馈'。

Next, I go to my newly created tasks to be refiled from the block
agenda with =F12 a= and clock in an email task and deal with it.
Repeat this until all of the 'Respond to <user>' tasks are marked
=DONE=.
接下来，我会按 =F12 a= 把新建的task refile到block agenda中，做一个邮件的task打卡计时

I read email and newgroups in Gnus so I don't separate clocked time
for quickly looking at things.  If an article has a useful piece of
information I want to remember I create a note for it with =C-c c n=
and enter the topic and file it.  This takes practically no time at
all and I know the note is safely filed for later retrieval.  The time
I spend in the capture buffer is clocked with that capture note.

** 9 Time Clocking 计时
I now use the concept of =punching in= and =punching out= at the start and end of my work day. I punch in when I arrive at work, punch out for lunch, punch in after lunch, and punch out at the end of the day. Every minute is clocked between punch-in and punch-out times. 

I'll work on this file in the following sequence:

计时的流程：

1. I punch in with =F9-I= at the start of my day

   按 =F9-I= 打卡

   That clocks in the =Organization= task by id in my =todo.org= file.

2. =F12-SPC= to review my block agenda

   按 =F12-SPC= 检查阻塞的日程表

   Pick 'TODO Some miscellaneous task' to work on next and clock that in with =I= The clock is now on 'TODO Some miscellaneous task'

   选一个要开始的task执行并计时，按 =I= 键

3. I complete that task and mark it done with =C-c C-t d=

   按 =C-c C-t d= 把一个task标记为已完成，tag会变成 DONE 。

   This stops the clock and moves it back to the =Organization= task.

4. Now I want to work on =Project A= so I clock in =Task 1=

   I work on Task 1 and mark it =DONE=.  This clocks out =Task 1= and moves
   the clock to =Project A=.  Now I work on =Task 2= and clock that in.

The entire time I'm working on and clocking some subtask of =Project A= all of the clock time in the interval is applied somewhere to the =Project A= tree.  When I eventually mark =Project A= done then the clock will move back to the default organization task.

*** 9.1 Clock Setup 设置计时

 To get started we need to punch in which clocks in the default task and keeps the clock running. This is now simply a matter of punching in the clock with F9 I. You can do this anywhere. Clocking out will now clock in the parent task (if there is one with a todo keyword) or clock in the default task if not parent exists.

Keeping the clock running when moving a subtask to a DONE state means clocking continues to apply to the project task. I can pick the next task from the parent and clock that in without losing a minute or two while I'm deciding what to work on next.

I keep clock times, state changes, and other notes in the :LOGBOOK: drawer.

I have the following org-mode settings for clocking: 

#+BEGIN_SRC emacs-lisp
;; Resume clocking task when emacs is restarted
(org-clock-persistence-insinuate)

;; Show lot of clocking history so it's easy to pick items off the C-F11 list
(setq org-clock-history-length 23)
;; Resume clocking task on clock-in if the clock is open
(setq org-clock-in-resume t)
;; Change tasks to NEXT when clocking in
(setq org-clock-in-switch-to-state 'bh/clock-in-to-next)
;; Separate drawers for clocking and logs
(setq org-drawers (quote ("PROPERTIES" "LOGBOOK")))
;; Save clock data and state changes and notes in the LOGBOOK drawer
(setq org-clock-into-drawer t)
;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks with 0:00 duration
(setq org-clock-out-remove-zero-time-clocks t)
;; Clock out when moving task to a done state
(setq org-clock-out-when-done t)
;; Save the running clock and all clock history when exiting Emacs, load it on startup
(setq org-clock-persist t)
;; Do not prompt to resume an active clock
(setq org-clock-persist-query-resume nil)
;; Enable auto clock resolution for finding open clocks
(setq org-clock-auto-clock-resolution (quote when-no-clock-is-running))
;; Include current clocking task in clock reports
(setq org-clock-report-include-clocking-task t)

(setq bh/keep-clock-running nil)

(defun bh/clock-in-to-next (kw)
  "Switch a task from TODO to NEXT when clocking in.
Skips capture tasks, projects, and subprojects.
Switch projects and subprojects from NEXT back to TODO"
  (when (not (and (boundp 'org-capture-mode) org-capture-mode))
    (cond
     ((and (member (org-get-todo-state) (list "TODO"))
           (bh/is-task-p))
      "NEXT")
     ((and (member (org-get-todo-state) (list "NEXT"))
           (bh/is-project-p))
      "TODO"))))

(defun bh/find-project-task ()
  "Move point to the parent (project) task if any"
  (save-restriction
    (widen)
    (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
      (while (org-up-heading-safe)
        (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
          (setq parent-task (point))))
      (goto-char parent-task)
      parent-task)))

(defun bh/punch-in (arg)
  "Start continuous clocking and set the default task to the
selected task.  If no task is selected set the Organization task
as the default task."
  (interactive "p")
  (setq bh/keep-clock-running t)
  (if (equal major-mode 'org-agenda-mode)
      ;;
      ;; We're in the agenda
      ;;
      (let* ((marker (org-get-at-bol 'org-hd-marker))
             (tags (org-with-point-at marker (org-get-tags-at))))
        (if (and (eq arg 4) tags)
            (org-agenda-clock-in '(16))
          (bh/clock-in-organization-task-as-default)))
    ;;
    ;; We are not in the agenda
    ;;
    (save-restriction
      (widen)
      ; Find the tags on the current task
      (if (and (equal major-mode 'org-mode) (not (org-before-first-heading-p)) (eq arg 4))
          (org-clock-in '(16))
        (bh/clock-in-organization-task-as-default)))))

(defun bh/punch-out ()
  (interactive)
  (setq bh/keep-clock-running nil)
  (when (org-clock-is-active)
    (org-clock-out))
  (org-agenda-remove-restriction-lock))

(defun bh/clock-in-default-task ()
  (save-excursion
    (org-with-point-at org-clock-default-task
      (org-clock-in))))

(defun bh/clock-in-parent-task ()
  "Move point to the parent (project) task if any and clock in"
  (let ((parent-task))
    (save-excursion
      (save-restriction
        (widen)
        (while (and (not parent-task) (org-up-heading-safe))
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq parent-task (point))))
        (if parent-task
            (org-with-point-at parent-task
              (org-clock-in))
          (when bh/keep-clock-running
            (bh/clock-in-default-task)))))))

(defvar bh/organization-task-id "eb155a82-92b2-4f25-a3c6-0304591af2f9")

(defun bh/clock-in-organization-task-as-default ()
  (interactive)
  (org-with-point-at (org-id-find bh/organization-task-id 'marker)
    (org-clock-in '(16))))

(defun bh/clock-out-maybe ()
  (when (and bh/keep-clock-running
             (not org-clock-clocking-in)
             (marker-buffer org-clock-default-task)
             (not org-clock-resolving-clocks-due-to-idleness))
    (bh/clock-in-parent-task)))

(add-hook 'org-clock-out-hook 'bh/clock-out-maybe 'append)
#+END_SRC

I used to clock in tasks by ID using the following function but with the new punch-in and punch-out I don't need these as much anymore. =f9-SPC= calls =bh/clock-in-last-task= which switches the clock back to the previously clocked task.

#+BEGIN_SRC emacs-lisp
;; (use-package org-id
;;   :defer t)
;; 
;; (defun bh/clock-in-task-by-id (id)
;;   "Clock in a task by id"
;;   (org-with-point-at (org-id-find id 'marker)
;;     (org-clock-in nil)))
;; 
(defun bh/clock-in-last-task (arg)
  "Clock in the interrupted task if there is one
Skip the default task and get the next one.
A prefix arg forces clock in of the default task."
  (interactive "p")
  (let ((clock-in-to-task
         (cond
          ((eq arg 4) org-clock-default-task)
          ((and (org-clock-is-active)
                (equal org-clock-default-task (cadr org-clock-history)))
           (caddr org-clock-history))
          ((org-clock-is-active) (cadr org-clock-history))
          ((equal org-clock-default-task (car org-clock-history)) (cadr org-clock-history))
          (t (car org-clock-history)))))
    (widen)
    (org-with-point-at clock-in-to-task
      (org-clock-in nil))))
#+END_SRC

*** 9.2 Clocking in 打卡计时
:PROPERTIES:
:CUSTOM_ID: ClockingIn
:END:

When I start or continue working on a task I clock it in with any of the following:

当开始或者继续一个task的时候，用下面的快捷键进行打卡计时

  - =C-c C-x C-i= 
  - =I= in the agenda
  - =I= speed key on the first character of the heading line
  - =f9 I= while on the task in the agenda
  - =f9 I= while in the task in an org file

** 10 Time reporting and tracking
*** 10.2 Task Estimates and column view 任务评估

Estimating how long tasks take to complete is a difficult skill to master. Org-mode makes it easy to practice creating estimates for tasks and then clock the actual time it takes to complete.

By repeatedly estimating tasks and reviewing how your estimate relates to the actual time clocked you can tune your estimating skills.

**** 10.2.1 Creating a task estimate with column mode
I use =properties= and =column view= to do project estimates.

用 =properties= 和 =column view= 进行项目评估。

I set up *column view* globally with the following headlines 

=column view= 的headlines用下面配置的格式 
#+BEGIN_SRC emacs-lisp
; Set default column view headings: Task Effort Clock_Summary
(setq org-columns-default-format "%80ITEM(Task) %10Effort(Effort){:} %10CLOCKSUM")
#+END_SRC

This makes column view show estimated task effort and clocked times side-by-side which is great for reviewing your project estimates.

A property called Effort records the estimated amount of time a given task will take to complete. The estimate times I use are one of:

名为Effort的property记录了完成一个task所需要的时间。用下面几种时间:

  + 10 minutes
  + 30 minutes
  + 1 hour
  + 2 hours
  + 3 hours
  + 4 hours
  + 5 hours
  + 6 hours
  + 7 hours
  + 8 hours

These are stored for easy use in =column mode= in the global property =Effort_ALL.= 

#+BEGIN_SRC emacs-lisp
; global Effort estimate values
; global STYLE property values for completion
(setq org-global-properties (quote (("Effort_ALL" . "0:15 0:30 0:45 1:00 2:00 3:00 4:00 5:00 6:00 0:00")
                                    ("STYLE_ALL" . "habit"))))
#+END_SRC

To create an estimate for a task or subtree start column mode with =C-c C-x C-c= and collapse the tree with =c=.  This shows a table overlayed on top of the headlines with the task name, effort estimate, and clocked time in columns.

评估一项任务或者子任务数用 =C-c C-x C-c= 或者 M-x org-columns，在task名这行显示时间表。

With the cursor in the =Effort= column for a task you can easily set the estimated effort value with the quick keys =1= through =9=.

当光标在一个task的 =Effort= 栏后，可以按0~9数字键快速输入完成task所需要的时间。

After setting the effort values exit =column mode= with =q=.

输入完task评估时间后，按 =q= 键 退出 =column mode=

*** 10.3 Providing progress reports to others

#+BEGIN_SRC emacs-lisp
;; Agenda log mode items to display (closed and state changes by default)
(setq org-agenda-log-mode-items (quote (closed state)))
#+END_SRC

** 11 Tags
*** 11.1 Tags

Tags with fast selection keys
#+BEGIN_SRC emacs-lisp
(setq org-tag-alist (quote ((:startgroup)
                            ("@errand" . ?e)
                            ("@office" . ?o)
                            ("@home" . ?H)
                            (:endgroup)
                            ("WAITING" . ?w)
                            ("HOLD" . ?h)
                            ("PERSONAL" . ?P)
                            ("WORK" . ?W)
                            ("ORG" . ?O)
                            ("ALBERT" . ?A)
                            ("NOTE" . ?n)
                            ("CANCELLED" . ?c)
                            ("FLAGGED" . ??))))

; Allow setting single tags without the menu
(setq org-fast-tag-selection-single-key (quote expert))

; For tag searches ignore tasks with scheduled and deadline dates
(setq org-agenda-tags-todo-honor-ignore-options t)
#+END_SRC
** 12 Handling Notes

Notes are little gems of knowledge that you come across during your day. They are just like tasks except there is nothing to do (except learn and memorize the gem of knowledge). Unfortunately there are way too many gems to remember and my head explodes just thinking about it.

org-mode to the rescue!

Often I'll find some cool feature or thing I want to remember while reading the org-mode and git mailing lists in Gnus. To create a note I use my note capture template C-c c n, type a heading for the note and C-c C-c to save it. The only other thing to do is to refile it (later) to the appropriate project file.

看见一下有意思的东西可以用note模板进行记录，按 =C-c c n= ，然后输入note的标题，再按 =C-c C-c= 保存。剩下要做的事是以后找个合适的file保存这个node。

I have an agenda view just to find notes. Notes are refiled to an appropriate project file and task. If there is no specific task it belongs to it goes to the catchall * Notes task. I generally have a catchall notes task in every project file. Notes are created with a NOTE tag already applied by the capture template so I'm free to refile the note anywhere. As long as the note is in a project file that contributes to my agenda (ie. in org-agenda-files) then I can find the note back easily with my notes agenda view by hitting the key combination F12 N. I'm free to limit the agenda view of notes using standard agenda tag filtering.

agenda view中能找到创建的notes。notes最终会被refiled到合适的project file和task。

Short notes with a meaningful headline are a great way to remember technical details without the need to actually remember anything - other than how to find them back when you need them using F12 N.

按 =F12 N=

Notes that are project related and not generally useful can be archived with the project and removed from the agenda when the project is removed.

So my org notes go in org.org and my git notes go in git.org both under the * Notes task. I'll forever be able to find those. A note about some work project detail I want to remember with the project is filed to the project task under the appropriate work org-mode file and eventually gets removed from the agenda when the project is complete and archived.

** 14 GTD stuff
*** 14.2 Project definition and finding stuck projects

#+BEGIN_SRC emacs-lisp
(setq org-stuck-projects (quote ("" nil nil "")))

(defun bh/is-project-p ()
  "Any task with a todo keyword subtask"
  (save-restriction
    (widen)
    (let ((has-subtask)
          (subtree-end (save-excursion (org-end-of-subtree t)))
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (forward-line 1)
        (while (and (not has-subtask)
                    (< (point) subtree-end)
                    (re-search-forward "^\*+ " subtree-end t))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      (and is-a-task has-subtask))))

(defun bh/is-project-subtree-p ()
  "Any task with a todo keyword that is in a project subtree.
Callers of this function already widen the buffer view."
  (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                              (point))))
    (save-excursion
      (bh/find-project-task)
      (if (equal (point) task)
          nil
        t))))

(defun bh/is-task-p ()
  "Any task with a todo keyword and no subtask"
  (save-restriction
    (widen)
    (let ((has-subtask)
          (subtree-end (save-excursion (org-end-of-subtree t)))
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (forward-line 1)
        (while (and (not has-subtask)
                    (< (point) subtree-end)
                    (re-search-forward "^\*+ " subtree-end t))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      (and is-a-task (not has-subtask)))))

(defun bh/is-subproject-p ()
  "Any task which is a subtask of another project"
  (let ((is-subproject)
        (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
    (save-excursion
      (while (and (not is-subproject) (org-up-heading-safe))
        (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
          (setq is-subproject t))))
    (and is-a-task is-subproject)))

(defun bh/list-sublevels-for-projects-indented ()
  "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
  This is normally used by skipping functions where this variable is already local to the agenda."
  (if (marker-buffer org-agenda-restrict-begin)
      (setq org-tags-match-list-sublevels 'indented)
    (setq org-tags-match-list-sublevels nil))
  nil)

(defun bh/list-sublevels-for-projects ()
  "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
  This is normally used by skipping functions where this variable is already local to the agenda."
  (if (marker-buffer org-agenda-restrict-begin)
      (setq org-tags-match-list-sublevels t)
    (setq org-tags-match-list-sublevels nil))
  nil)

(defvar bh/hide-scheduled-and-waiting-next-tasks t)

(defun bh/toggle-next-task-display ()
  (interactive)
  (setq bh/hide-scheduled-and-waiting-next-tasks (not bh/hide-scheduled-and-waiting-next-tasks))
  (when  (equal major-mode 'org-agenda-mode)
    (org-agenda-redo))
  (message "%s WAITING and SCHEDULED NEXT Tasks" (if bh/hide-scheduled-and-waiting-next-tasks "Hide" "Show")))

(defun bh/skip-stuck-projects ()
  "Skip trees that are not stuck projects"
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (if (bh/is-project-p)
          (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                 (has-next ))
            (save-excursion
              (forward-line 1)
              (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                (unless (member "WAITING" (org-get-tags-at))
                  (setq has-next t))))
            (if has-next
                nil
              next-headline)) ; a stuck project, has subtasks but no next task
        nil))))

(defun bh/skip-non-stuck-projects ()
  "Skip trees that are not stuck projects"
  ;; (bh/list-sublevels-for-projects-indented)
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (if (bh/is-project-p)
          (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                 (has-next ))
            (save-excursion
              (forward-line 1)
              (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                (unless (member "WAITING" (org-get-tags-at))
                  (setq has-next t))))
            (if has-next
                next-headline
              nil)) ; a stuck project, has subtasks but no next task
        next-headline))))

(defun bh/skip-non-projects ()
  "Skip trees that are not projects"
  ;; (bh/list-sublevels-for-projects-indented)
  (if (save-excursion (bh/skip-non-stuck-projects))
      (save-restriction
        (widen)
        (let ((subtree-end (save-excursion (org-end-of-subtree t))))
          (cond
           ((bh/is-project-p)
            nil)
           ((and (bh/is-project-subtree-p) (not (bh/is-task-p)))
            nil)
           (t
            subtree-end))))
    (save-excursion (org-end-of-subtree t))))

(defun bh/skip-project-trees-and-habits ()
  "Skip trees that are projects"
  (save-restriction
    (widen)
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (cond
       ((bh/is-project-p)
        subtree-end)
       ((org-is-habit-p)
        subtree-end)
       (t
        nil)))))

(defun bh/skip-projects-and-habits-and-single-tasks ()
  "Skip trees that are projects, tasks that are habits, single non-project tasks"
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((org-is-habit-p)
        next-headline)
       ((and bh/hide-scheduled-and-waiting-next-tasks
             (member "WAITING" (org-get-tags-at)))
        next-headline)
       ((bh/is-project-p)
        next-headline)
       ((and (bh/is-task-p) (not (bh/is-project-subtree-p)))
        next-headline)
       (t
        nil)))))

(defun bh/skip-project-tasks-maybe ()
  "Show tasks related to the current restriction.
When restricted to a project, skip project and sub project tasks, habits, NEXT tasks, and loose tasks.
When not restricted, skip project and sub-project tasks, habits, and project related tasks."
  (save-restriction
    (widen)
    (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
           (next-headline (save-excursion (or (outline-next-heading) (point-max))))
           (limit-to-project (marker-buffer org-agenda-restrict-begin)))
      (cond
       ((bh/is-project-p)
        next-headline)
       ((org-is-habit-p)
        subtree-end)
       ((and (not limit-to-project)
             (bh/is-project-subtree-p))
        subtree-end)
       ((and limit-to-project
             (bh/is-project-subtree-p)
             (member (org-get-todo-state) (list "NEXT")))
        subtree-end)
       (t
        nil)))))

(defun bh/skip-project-tasks ()
  "Show non-project tasks.
Skip project and sub-project tasks, habits, and project related tasks."
  (save-restriction
    (widen)
    (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
      (cond
       ((bh/is-project-p)
        subtree-end)
       ((org-is-habit-p)
        subtree-end)
       ((bh/is-project-subtree-p)
        subtree-end)
       (t
        nil)))))

(defun bh/skip-non-project-tasks ()
  "Show project tasks.
Skip project and sub-project tasks, habits, and loose non-project tasks."
  (save-restriction
    (widen)
    (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
           (next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((bh/is-project-p)
        next-headline)
       ((org-is-habit-p)
        subtree-end)
       ((and (bh/is-project-subtree-p)
             (member (org-get-todo-state) (list "NEXT")))
        subtree-end)
       ((not (bh/is-project-subtree-p))
        subtree-end)
       (t
        nil)))))

(defun bh/skip-projects-and-habits ()
  "Skip trees that are projects and tasks that are habits"
  (save-restriction
    (widen)
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (cond
       ((bh/is-project-p)
        subtree-end)
       ((org-is-habit-p)
        subtree-end)
       (t
        nil)))))

(defun bh/skip-non-subprojects ()
  "Skip trees that are not projects"
  (let ((next-headline (save-excursion (outline-next-heading))))
    (if (bh/is-subproject-p)
        nil
      next-headline)))
#+END_SRC
** 16 Publishing and Exporting
*** 16.2 plantuml

[2018-09-29 周六 22:59:28] 中文乱码的解决方法 begin_src plantuml :file img/chinese.png :cmdline -charset utf-8

#+BEGIN_SRC emacs-lisp
(setq org-plantuml-jar-path "~/java/plantuml.jar")

(add-hook 'org-babel-after-execute-hook 'bh/display-inline-images 'append)

; Make babel results blocks lowercase
(setq org-babel-results-keyword "results")

(defun bh/display-inline-images ()
  (condition-case nil
      (org-display-inline-images)
    (error nil)))

(org-babel-do-load-languages
 (quote org-babel-load-languages)
 (quote ((emacs-lisp . t)
         (dot . t)
         ;; (ditaa . t)
         ;; (R . t)
         ;; (python . t)
         ;; (ruby . t)
         ;; (gnuplot . t)
         ;; (clojure . t)
         ;; (sh . t)
         ;; (ledger . t)
         ;; (org . t)
         ;; (latex . t)
         (plantuml . t)
)))

; Do not prompt to confirm evaluation
; This may be dangerous - make sure you understand the consequences
; of setting this -- see the docstring for details
(setq org-confirm-babel-evaluate nil)

; Use fundamental mode when editing plantuml blocks with C-c '
(add-to-list 'org-src-lang-modes (quote ("plantuml" . fundamental)))
#+END_SRC

#+results:
: ((plantuml . fundamental) (ocaml . tuareg) (elisp . emacs-lisp) (ditaa . artist) (asymptote . asy) (dot . fundamental) (sqlite . sql) (calc . fundamental) (C . c) (cpp . c++) (C++ . c++) (screen . shell-script) (shell . sh) (bash . sh))

** 18 Productivity Tools
*** 18.2.1 Narrowing to a subtree with bh/org-todo

#+BEGIN_SRC emacs-lisp
;;(global-set-key (kbd "<f3>") 'bh/org-todo)

(defun bh/org-todo (arg)
  (interactive "p")
  (if (equal arg 4)
      (save-restriction
        (bh/narrow-to-org-subtree)
        (org-show-todo-tree nil))
    (bh/narrow-to-org-subtree)
    (org-show-todo-tree nil)))

;;(global-set-key (kbd "<S-f5>") 'bh/widen)

(defun bh/widen ()
  (interactive)
  (if (equal major-mode 'org-agenda-mode)
      (progn
        (org-agenda-remove-restriction-lock)
        (when org-agenda-sticky
          (org-agenda-redo)))
    (widen)))

(add-hook 'org-agenda-mode-hook
          '(lambda () (org-defkey org-agenda-mode-map "W" (lambda () (interactive) (setq bh/hide-scheduled-and-waiting-next-tasks t) (bh/widen))))
          'append)

(defun bh/restrict-to-file-or-follow (arg)
  "Set agenda restriction to 'file or with argument invoke follow mode.
I don't use follow mode very often but I restrict to file all the time
so change the default 'F' binding in the agenda to allow both"
  (interactive "p")
  (if (equal arg 4)
      (org-agenda-follow-mode)
    (widen)
    (bh/set-agenda-restriction-lock 4)
    (org-agenda-redo)
    (beginning-of-buffer)))

(add-hook 'org-agenda-mode-hook
          '(lambda () (org-defkey org-agenda-mode-map "F" 'bh/restrict-to-file-or-follow))
          'append)

(defun bh/narrow-to-org-subtree ()
  (widen)
  (org-narrow-to-subtree)
  (save-restriction
    (org-agenda-set-restriction-lock)))

(defun bh/narrow-to-subtree ()
  (interactive)
  (if (equal major-mode 'org-agenda-mode)
      (progn
        (org-with-point-at (org-get-at-bol 'org-hd-marker)
          (bh/narrow-to-org-subtree))
        (when org-agenda-sticky
          (org-agenda-redo)))
    (bh/narrow-to-org-subtree)))

(add-hook 'org-agenda-mode-hook
          '(lambda () (org-defkey org-agenda-mode-map "N" 'bh/narrow-to-subtree))
          'append)

(defun bh/narrow-up-one-org-level ()
  (widen)
  (save-excursion
    (outline-up-heading 1 'invisible-ok)
    (bh/narrow-to-org-subtree)))

(defun bh/get-pom-from-agenda-restriction-or-point ()
  (or (org-get-at-bol 'org-hd-marker)
      (and (marker-position org-agenda-restrict-begin) org-agenda-restrict-begin)
      (and (equal major-mode 'org-mode) (point))
      org-clock-marker))

(defun bh/narrow-up-one-level ()
  (interactive)
  (if (equal major-mode 'org-agenda-mode)
      (org-with-point-at (bh/get-pom-from-agenda-restriction-or-point)
        (bh/narrow-up-one-org-level))
    (bh/narrow-up-one-org-level)))

(add-hook 'org-agenda-mode-hook
          '(lambda () (org-defkey org-agenda-mode-map "U" 'bh/narrow-up-one-level))
          'append)

(defun bh/narrow-to-org-project ()
  (widen)
  (save-excursion
    (bh/find-project-task)
    (bh/narrow-to-org-subtree)))

(defun bh/narrow-to-project ()
  (interactive)
  (if (equal major-mode 'org-agenda-mode)
      (progn
        (org-with-point-at (bh/get-pom-from-agenda-restriction-or-point)
          (bh/narrow-to-org-project)
          (save-excursion
            (bh/find-project-task)
            (org-agenda-set-restriction-lock)))
        (org-agenda-redo)
        (beginning-of-buffer))
    (bh/narrow-to-org-project)
    (save-restriction
      (org-agenda-set-restriction-lock))))

(add-hook 'org-agenda-mode-hook
          '(lambda () (org-defkey org-agenda-mode-map "P" 'bh/narrow-to-project))
          'append)

(defvar bh/project-list nil)

(defun bh/view-next-project ()
  (interactive)
  (let (num-project-left current-project)
    (unless (marker-position org-agenda-restrict-begin)
      (goto-char (point-min))
      ; Clear all of the existing markers on the list
      (while bh/project-list
        (set-marker (pop bh/project-list) nil))
      (re-search-forward "Tasks to Refile")
      (forward-visible-line 1))

    ; Build a new project marker list
    (unless bh/project-list
      (while (< (point) (point-max))
        (while (and (< (point) (point-max))
                    (or (not (org-get-at-bol 'org-hd-marker))
                        (org-with-point-at (org-get-at-bol 'org-hd-marker)
                          (or (not (bh/is-project-p))
                              (bh/is-project-subtree-p)))))
          (forward-visible-line 1))
        (when (< (point) (point-max))
          (add-to-list 'bh/project-list (copy-marker (org-get-at-bol 'org-hd-marker)) 'append))
        (forward-visible-line 1)))

    ; Pop off the first marker on the list and display
    (setq current-project (pop bh/project-list))
    (when current-project
      (org-with-point-at current-project
        (setq bh/hide-scheduled-and-waiting-next-tasks nil)
        (bh/narrow-to-project))
      ; Remove the marker
      (setq current-project nil)
      (org-agenda-redo)
      (beginning-of-buffer)
      (setq num-projects-left (length bh/project-list))
      (if (> num-projects-left 0)
          (message "%s projects left to view" num-projects-left)
        (beginning-of-buffer)
        (setq bh/hide-scheduled-and-waiting-next-tasks t)
        (error "All projects viewed.")))))

(add-hook 'org-agenda-mode-hook
          '(lambda () (org-defkey org-agenda-mode-map "V" 'bh/view-next-project))
          'append)

(setq org-show-entry-below (quote ((default))))
#+END_SRC

*** 18.3 Tuning the Agenda Views

Always hilight the current agenda line
#+BEGIN_SRC emacs-lisp
(add-hook 'org-agenda-mode-hook
          '(lambda () (hl-line-mode 1))
          'append)
#+END_SRC

[2019-06-10 周一 12:36:03] 去掉mode-line中的clock高亮设置的背景色。
#+BEGIN_SRC emacs-lisp
;; The following custom-set-faces create the highlights
(custom-set-faces
  ;; custom-set-faces was added by Custom.
  ;; If you edit it by hand, you could mess it up, so be careful.
  ;; Your init file should contain only one such instance.
  ;; If there is more than one, they won't work right.
 ;; '(org-mode-line-clock ((t (:background "grey75" :foreground "red" :box (:line-width -1 :style released-button)))) t))
 '(org-mode-line-clock ((t (:background nil :foreground "red" :box (:line-width -1 :style released-button)))) t))
#+END_SRC

**** 18.3.2 Keep tasks with timestamps visible on the global todo lists

#+BEGIN_SRC emacs-lisp
;; Keep tasks with dates on the global todo lists
(setq org-agenda-todo-ignore-with-date nil)

;; Keep tasks with deadlines on the global todo lists
(setq org-agenda-todo-ignore-deadlines nil)

;; Keep tasks with scheduled dates on the global todo lists
(setq org-agenda-todo-ignore-scheduled nil)

;; Keep tasks with timestamps on the global todo lists
(setq org-agenda-todo-ignore-timestamp nil)

;; Remove completed deadline tasks from the agenda view
(setq org-agenda-skip-deadline-if-done t)

;; Remove completed scheduled tasks from the agenda view
(setq org-agenda-skip-scheduled-if-done t)

;; Remove completed items from search results
(setq org-agenda-skip-timestamp-if-done t)
#+END_SRC

**** 18.3.4 Searches include archive files

#+BEGIN_SRC emacs-lisp
;; Include agenda archive files when searching for things
(setq org-agenda-text-search-extra-files (quote (agenda-archives)))
#+END_SRC

**** 18.3.5 Agenda view tweaks

#+BEGIN_SRC emacs-lisp
;; Show all future entries for repeating tasks
(setq org-agenda-repeating-timestamp-show-all t)

;; Show all agenda dates - even if they are empty
(setq org-agenda-show-all-dates t)

;; Sorting order for tasks on the agenda
(setq org-agenda-sorting-strategy
      (quote ((agenda habit-down time-up user-defined-up effort-up category-keep)
              (todo category-up effort-up)
              (tags category-up effort-up)
              (search category-up))))

;; Start the weekly agenda on Monday
(setq org-agenda-start-on-weekday 1)

;; Enable display of the time grid so we can see the marker for the current time
(setq org-agenda-time-grid (quote ((daily today remove-match)
                                   #("----------------" 0 16 (org-heading t))
                                   (0900 1100 1300 1500 1700))))

;; Display tags farther right
(setq org-agenda-tags-column -102)

;;
;; Agenda sorting functions
;;
(setq org-agenda-cmp-user-defined 'bh/agenda-sort)

(defun bh/agenda-sort (a b)
  "Sorting strategy for agenda items.
Late deadlines first, then scheduled, then non-late deadlines"
  (let (result num-a num-b)
    (cond
     ; time specific items are already sorted first by org-agenda-sorting-strategy

     ; non-deadline and non-scheduled items next
     ((bh/agenda-sort-test 'bh/is-not-scheduled-or-deadline a b))

     ; deadlines for today next
     ((bh/agenda-sort-test 'bh/is-due-deadline a b))

     ; late deadlines next
     ((bh/agenda-sort-test-num 'bh/is-late-deadline '> a b))

     ; scheduled items for today next
     ((bh/agenda-sort-test 'bh/is-scheduled-today a b))

     ; late scheduled items next
     ((bh/agenda-sort-test-num 'bh/is-scheduled-late '> a b))

     ; pending deadlines last
     ((bh/agenda-sort-test-num 'bh/is-pending-deadline '< a b))

     ; finally default to unsorted
     (t (setq result nil)))
    result))

(defmacro bh/agenda-sort-test (fn a b)
  "Test for agenda sort"
  `(cond
    ; if both match leave them unsorted
    ((and (apply ,fn (list ,a))
          (apply ,fn (list ,b)))
     (setq result nil))
    ; if a matches put a first
    ((apply ,fn (list ,a))
     (setq result -1))
    ; otherwise if b matches put b first
    ((apply ,fn (list ,b))
     (setq result 1))
    ; if none match leave them unsorted
    (t nil)))

(defmacro bh/agenda-sort-test-num (fn compfn a b)
  `(cond
    ((apply ,fn (list ,a))
     (setq num-a (string-to-number (match-string 1 ,a)))
     (if (apply ,fn (list ,b))
         (progn
           (setq num-b (string-to-number (match-string 1 ,b)))
           (setq result (if (apply ,compfn (list num-a num-b))
                            -1
                          1)))
       (setq result -1)))
    ((apply ,fn (list ,b))
     (setq result 1))
    (t nil)))

(defun bh/is-not-scheduled-or-deadline (date-str)
  (and (not (bh/is-deadline date-str))
       (not (bh/is-scheduled date-str))))

(defun bh/is-due-deadline (date-str)
  (string-match "Deadline:" date-str))

(defun bh/is-late-deadline (date-str)
  (string-match "\\([0-9]*\\) d\. ago:" date-str))

(defun bh/is-pending-deadline (date-str)
  (string-match "In \\([^-]*\\)d\.:" date-str))

(defun bh/is-deadline (date-str)
  (or (bh/is-due-deadline date-str)
      (bh/is-late-deadline date-str)
      (bh/is-pending-deadline date-str)))

(defun bh/is-scheduled (date-str)
  (or (bh/is-scheduled-today date-str)
      (bh/is-scheduled-late date-str)))

(defun bh/is-scheduled-today (date-str)
  (string-match "Scheduled:" date-str))

(defun bh/is-scheduled-late (date-str)
  (string-match "Sched\.\\(.*\\)x:" date-str))
#+END_SRC

**** 18.3.6 Sticky Agendas

#+BEGIN_SRC emacs-lisp
;; I normally have two views displayed (F12 a for the daily/weekly agenda and F12 SPC for my project management view) 

;; Use sticky agenda's so they persist
(setq org-agenda-sticky t)
#+END_SRC

**** 18.7.2 org-indent mode
默认的大纲显示没有缩进，显得有些乱。可以用M-x org-indent-mode切换。
#+BEGIN_SRC emacs-lisp
(setq org-startup-indented t)
#+END_SRC

**** 18.12 Logging Stuff

#+BEGIN_SRC emacs-lisp
(setq org-log-done (quote time))
(setq org-log-into-drawer t)
(setq org-log-state-notes-insert-after-drawers nil)

(setq org-todo-keywords
      (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
              (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "PHONE" "MEETING"))))
#+END_SRC

*** 18.17 Handling Encryption

I used to keep my encrypted data like account passwords in a separate GPG encrypted file. Now I keep them in my org-mode files with a special tag instead. Encrypted data is kept in the org-mode file that it is associated with.

org-crypt allows you to tag headings with a special tag crypt and org-mode can keep data in these headings encrypted when saved to disk. You decrypt the heading temporarily when you need access to the data and org-mode re-encrypts the heading as soon as you save the file.

I use the following setup for encryption:

org-crypt是org-mode自带的。使用require加载耗时12ms，可以接受。
[2019-06-05 周三 10:03:54] 为什么用use-package会报错?
#+BEGIN_SRC emacs-lisp
;; (use-package org-crypt
;;   ;; :defer t
;;   :ensure nil
;;   :init
;;     (progn
;;       ; Encrypt all entries before saving
;;       (org-crypt-use-before-save-magic)
;;       (setq org-tags-exclude-from-inheritance (quote ("crypt")))
;;       ; GPG key to use for encryption
;;       ;; (setq org-crypt-key "F0B66B40")
;;       ;; 使用对称加密算法加密
;;       (setq org-crypt-key nil)
;;     ))

;; (setq epg-debug t)
;; (setq epg-gpg-home-directory "C:/Users/Albert/AppData/Roaming/gnupg")
;; (setq epg-gpg-program "E:/Program Files (x86)/GnuPG/bin/gpg.exe")
;; (setq epg-gpgconf-program "E:\\Program Files (x86)\\GnuPG\\bin\\gpgconf.exe")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require 'org-crypt)
; Encrypt all entries before saving
(org-crypt-use-before-save-magic)
(setq org-tags-exclude-from-inheritance (quote ("crypt")))
;; nil 使用对称加密算法加密，非nil则使用公钥加密
;; (setq org-crypt-key nil)
;; keyid可以用key的username/email or pub的指纹的后8个字符
(setq org-crypt-key "georgealbert@qq.com")
#+END_SRC

=M-x org-set-property= 设置heading的properties为 =CRYPTKEY= 为某个key的id，单独对一个heading使用不同的加密方式和key。

用 =gpg --version= 确认gpg的HOME目录。

M-x org-decrypt-entry will prompt for the passphrase associated with your encryption key and replace the encrypted data where the point is with the plaintext details for your encrypted entry. As soon as you save the file the data is re-encrypted for your key. Encrypting does not require prompting for the passphrase - that's only for looking at the plain text version of the data.

I tend to have a single level 1 encrypted entry per file (like * Passwords). I prevent the crypt tag from using inheritance so that I don't have encrypted data inside encrypted data. I found M-x org-decrypt-entries prompting for the passphrase to decrypt data over and over again (once per entry to decrypt) too inconvenient.

I leave my entries encrypted unless I have to look up data - I decrypt on demand and then save the file again to re-encrypt the data. This keeps the data in plain text as short as possible.
**** 18.17.1 Auto Save Files

Emacs temporarily saves your buffer in an autosave file while you are editing your org buffer and a sufficient number of changes have accumulated. If you have decrypted subtrees in your buffer these will be written to disk in plain text which possibly leaks sensitive information. To combat this org-mode now asks if you want to disable the autosave functionality in this buffer.

Personally I really like the autosave feature. 99% of the time my encrypted entries are perfectly safe to write to the autosave file since they are still encrypted. I tend to decrypt an entry, read the details for what I need to look up and then immediately save the file again with C-x C-s which re-encrypts the entry immediately. This pretty much guarantees that my autosave files never have decrypted data stored in them.

I disable the default org crypt auto-save setting as follows:

#+BEGIN_SRC emacs-lisp
;; (setq org-crypt-disable-auto-save nil)
(setq org-crypt-disable-auto-save 'encrypt)
#+END_SRC

*** 18.44 Showing source block syntax highlighting

#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t)
#+END_SRC

ediff org mode时的folding有点讨厌。

#+BEGIN_SRC lisp
;;2014/05/02 16:43:50 ediff folded org file
;;(add-hook 'ediff-prepare-buffer-hook 'f-ediff-prepare-buffer-hook-setup)
;;(defun f-ediff-prepare-buffer-hook-setup ()
;;  ;; specific modes
;;  (cond ((eq major-mode 'org-mode)
;;         (f-org-vis-mod-maximum))
;;        ;; room for more modes
;;        )
;;  ;; all modes
;;  (setq truncate-lines nil))
;;(defun f-org-vis-mod-maximum ()
;;  "Visibility: Show the most possible."
;;  (cond
;;   ((eq major-mode 'org-mode)
;;    (visible-mode 1)  ; default 0
;;    (setq truncate-lines nil)  ; no `org-startup-truncated' in hook
;;    (setq org-hide-leading-stars t))  ; default nil
;;   (t
;;    (message "ERR: not in Org mode")
;;    (ding))))
#+END_SRC

*** 18.48 Allow alphabetical list entries

The following setting adds alphabetical lists like

a. item one
b. item two

#+BEGIN_SRC lisp
;; (setq org-alphabetical-lists t)
#+END_SRC

In order for filling to work correctly this needs to be set before the exporters are loaded.

** org2blog

[2018-11-23 周五 16:09:13] for github
#+BEGIN_SRC emacs-lisp
;; (use-package ox-publish
;;   :defer t)

(setq org-publish-project-alist
  '(
    ;; 把各部分的配置文件写到这里面来
    ("blog-notes"
      :base-directory "~/org/notes"
      :base-extension "org"
      ;:publishing-directory "~/org/public_html/"
      :publishing-directory "e:/workspace/georgealbert.github.io/"
      :recursive t
      :publishing-function org-html-publish-to-html
      :headline-levels 4             ; Just the default for this project.
      :auto-preamble t
      :section-numbers nil
      ;:with-date nil
      ;:author "Albert"
      ;:email "georgealbert@qq.com"
      ;:auto-sitemap t                ; Generate sitemap.org automagically...
      :sitemap-filename "index.org"  ; ... call it sitemap.org (it's the default)...
      ;:sitemap-title "Albert's blog"         ; ... with title 'Sitemap'.
      :with-toc nil                            ; 不要toc，否则太难看
      :sitemap-sort-files anti-chronologically
      :sitemap-file-entry-format "%d %t"
      :html-head-include-scripts nil           ; 不输出<head>中的javascript脚本
      :html-postamble nil                      ; 不输出creator、date和validation
      :html-validation-link nil
      :html-link-use-abs-url t                ; 用绝对路径，看看解决静态资源文件定位问题 [2018-11-24 周六 23:22:08]
      :html-doctype "html5"                    ; 用html5可以让html的代码输出少点
      ;:html-link-home "https://www.albertzhou.net"
      )
    ("blog-static"
      :base-directory "~/org/notes"
      :base-extension "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf"
      ;:publishing-directory "~/org/public_html/"
      :publishing-directory "e:/workspace/georgealbert.github.io/"
      :recursive t
      :publishing-function org-publish-attachment
      )
    ("blog" :components ("blog-notes" "blog-static"))
    ))
;(setq org-html-head "<link rel=\"stylesheet\" type=\"text/css\" href=\"home.css\" />
;<link rel=\"stylesheet\" type=\"text/css\" href=\"org.css\" />")
#+END_SRC

[2018-11-23 周五 23:19:16] HTML doctypes默认是"xhtml-strict"，改为"html4-strict"是不行的。
#+BEGIN_SRC emacs-lisp
;(setq org-html-doctype-alist '(("html5" . "<!DOCTYPE html>")))
#+END_SRC

[2018-11-24 周六 10:16:58] 不输出creator/data/validation，也不输出head中的javascript脚本
#+BEGIN_SRC emacs-lisp
;(setq org-html-postamble nil)
;(setq org-html-head-include-scripts nil)
(setq org-export-default-language "zh_CN")

;(setq org-html-validation-link nil)
;(setq org-export-with-date nil)
#+END_SRC

** 禁用下划线转义
org-mode的文档在导出到html时，有一个挺烦人的问题就是 abc_def 会变成 abcdef，这其实是一种类似TeX的 写法，主要也就是在少数场景下有意义（其实与之相伴的还有一个 10^24 会变成 1024，不过这个对我影响不大，因为我很少会用到这种写法）。

关闭这个功能的方法是在org文件头部的 OPTIONS 里面添加 ^:nil:

这样以来如果要输入下标，就要加{}
例如：
输入 X_{Y}, Y成为下标;
而输入 X_Y, 则依然输出 X_Y,
即下划线原样输出

;#+OPTIONS: ^:nil

#+BEGIN_SRC emacs-lisp
;(setq-default org-use-sub-superscripts nil)

(setq org-export-with-sub-superscripts nil) 
#+END_SRC

** 不输出css [2018-11-23 周五 22:34:57] 
turn off the default style, customize org-html-head-include-default-style variable, or use this option line in the Org file.

;#+OPTIONS: html-style:nil

#+BEGIN_SRC emacs-lisp
(setq org-html-head-include-default-style nil)
#+END_SRC
** html export
[2014-09-12 12:55:36] 为什么不管用呢？

#+BEGIN_SRC lisp
;(setq org-export-html-style-include-scripts nil
;   org-export-html-style-include-default nil
;   org-export-html-style-default nil
;   org-html-style-default nil)
 
;(setq org-export-html-style
;(setq org-html-head-include-default-style

;; (setq org-html-style-default
;;   "<link rel=\"stylesheet\" type=\"text/css\" href=\"css/org-manual.css\" />")
#+END_SRC
* 现在没用的配置
** 反显选中区域

emacs 23以后默认。
#+begin_src lisp
;(transient-mark-mode t) 
#+end_src
** Mode line format
[2014-09-16 18:18:58]

Display a more compact mode line.

#+BEGIN_SRC lisp
;(use-package smart-mode-line
;(defun my-line()
;  :init
;  (progn
;  (setq-default
;   mode-line-format 
;   '("%e"
;     mode-line-front-space
;     mode-line-mule-info
;     mode-line-client
;     mode-line-modified
;     mode-line-remote
;     mode-line-frame-identification
;     mode-line-buffer-identification
;     "   "
;     mode-line-position
;     (vc-mode vc-mode)
;     "  "
;     mode-line-modes
;     mode-line-misc-info
;     mode-line-end-spaces))))
;(my-line)
#+END_SRC
** ido

#+BEGIN_SRC lisp
;(require 'ido)
#+END_SRC

** smex
[2014-09-19 14:44:30] 有helm，不用smex了。

Smex is a M-x enhancement for Emacs. Built on top of IDO, it provides a convenient interface 
to your recently and most frequently used commands. And to all the other commands, too.

Extras: Limit commands to those relevant to the active major mode. Show frequently used commands that have no key bindings.

用了smex后，现在已经把command忘记得差不多了，现在magit的话，就会 *M-x magit* 直接联想了。呵呵。

#+BEGIN_SRC lisp
;(require 'smex)
;
;(global-set-key (kbd "M-x") 'smex)
;(global-set-key (kbd "M-X") 'smex-major-mode-commands)
;; This is your old M-x.
;;(global-set-key (kbd "C-c C-c M-x") 'execute-extended-command)
#+END_SRC
** htmlize

为了让org mode中的代码可以语法高亮，不知道新的org 8.2.7c是不是自带了，那就可以不用这个了。

#+BEGIN_SRC lisp
;(require 'htmlize)
#+END_SRC

** ace-jump [2014-11-20 周四 18:09:04]

#+BEGIN_SRC lisp
;;;
;;; ace jump mode major function
;;; 
;(autoload
;  'ace-jump-mode
;  "ace-jump-mode"
;  "Emacs quick move minor mode"
;  t)
;;; you can select the key you prefer to
;(define-key global-map (kbd "C-c SPC") 'ace-jump-mode)
;
;;; 
;;; enable a more powerful jump back function from ace jump mode
;;;
;(autoload
;  'ace-jump-mode-pop-mark
;  "ace-jump-mode"
;  "Ace jump back:-)"
;  t)
;(eval-after-load "ace-jump-mode"
;  '(ace-jump-mode-enable-mark-sync))
;(define-key global-map (kbd "C-x SPC") 'ace-jump-mode-pop-mark)
;
;;;If you use evil
;(define-key evil-normal-state-map (kbd "SPC") 'ace-jump-mode)
#+END_SRC 

