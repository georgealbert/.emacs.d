
* common setting
** 启动优化 [2019-05-18 周六 22:43:45]

doom-emacs介绍了它是如何做到启动速度这么快的 https://github.com/hlissner/doom-emacs/wiki/FAQ#how-is-dooms-startup-so-fast

Use lexical-binding everywhere. Add ;; -*- lexical-binding: t; -*- to the top of your elisp files. This can break code if you’ve written it to depend on dynamic variables, but I’ve written Doom not to.

[2019-05-18 周六 23:35:01] 好像没什么效果。
#+BEGIN_SRC emacs-lisp
;;; Albert.el -*- lexical-binding: t; -*-
#+END_SRC

[2019-05-18 周六 23:34:20] 学习anything的作者 https://github.com/manateelazycat/lazycat-emacs/blob/master/site-lisp/config/init.el

优化Emacs启动速度的方法论 https://manateelazycat.github.io/emacs/2019/05/12/emacs-optimize-startup-speed.html
*** garbage collector优化 [2019-05-20 周一 10:53:13]
[2019-05-18 周六 20:43:50] 从10s -> 5.5s左右，不知道效果能持续多久。
设置垃圾回收，在Windows下，emacs 25版本会频繁出发垃圾回收，所以需要设置。

[2019-05-18 周六 21:54:06] emacs 26.2启动时间15s，先注释掉吧。内存设置过大在长时间使用后gc会导致响应慢。
[2019-05-24 周五 09:12:45] 参考doom-emacs的init.el，代码放到在init.el里
#+BEGIN_SRC lisp
;; (when (eq system-type 'windows-nt)
;;   (setq gc-cons-threshold (* 512 1024 1024))
;;   (setq gc-cons-percentage 0.5)
;;   (run-with-idle-timer 5 t #'garbage-collect)
;;   ;; 显示垃圾回收信息，这个可以作为debug用
;;   (setq garbage-collection-messages t))
#+END_SRC

[2019-05-20 周一 10:48:24] https://github.com/jacmoe/emacs.d/blob/master/jacmoe.org

#+BEGIN_SRC lisp
;; (setq-default
;;   gc-cons-threshold most-positive-fixnum          ; Increase garbage collector treshold
;; )
#+END_SRC

Reset garbage collector treshold after initialization is finished and garbage-collect on focus-out. Emacs should feel snappier.
#+BEGIN_SRC lisp
;; (add-hook 'after-init-hook (lambda () (setq gc-cons-threshold 800000)))
;; (add-hook 'after-init-hook (lambda () (setq gc-cons-threshold (* 16 1024 1024))))
;; (add-hook 'focus-out-hook 'garbage-collect)
#+END_SRC
** elpa

#+BEGIN_SRC emacs-lisp
(require 'package)

(add-to-list 'package-archives
  '("melpa" . "http://melpa.org/packages/") t)

;; (unless (assoc-default "melpa" package-archives)
;;   (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t))
;; (unless (assoc-default "org" package-archives)
;;   (add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/") t))

(package-initialize)
;(setq package-user-dir (concat dotfiles-dir "/elpa"))

(unless (package-installed-p 'use-package)
  (package-install 'use-package))

;; [2019-01-11 周五 23:23:40] always-ensure一打开就起不来了，可能网络不好
(setq use-package-always-ensure t)
(setq use-package-verbose t)
(require 'use-package)

(use-package auto-compile
  :config (auto-compile-on-load-mode))
(setq load-prefer-newer t)
#+end_src

代理配置
;(setq url-proxy-services
;   '(("no_proxy" . "^\\(localhost\\|10.*\\)")
;     ("http" . "134.80.3.27:8080")
;     ("https" . "134.80.3.27:8080")))

** HOME
默认目录设为 =HOME= 目录，不设的话默认是 /emacs安装目录/bin/ 。

#+BEGIN_SRC emacs-lisp
(setq default-directory "~/")
#+END_SRC

** Window size

T430的屏幕长了一点，要是全屏的话，org mode的buffer会在右边打开，看见的内容太少了，
控制窗口大小，让buffer显示在下面。

#+BEGIN_SRC emacs-lisp
;; adjust the size of Emacs window for org mode agenda/todo list to display herizontal
(if (eq system-type 'windows-nt)
  ;; (setq default-frame-alist '((top . 0) (left . 0) (height . 42) (width . 159)))
  (toggle-frame-maximized)

  ;; "Maximize emacs window in windows os" WM_SYSCOMMAND #xf030 maximize  
  ;; [2018-09-07 周五 09:53:36] 不知道为什么没有效果
  ;; (interactive)
  ;; (w32-send-sys-command 61488)
)
#+END_SRC

** Font setting on win7/win10

可以用 C-u C-x = or C-u g a 来查看光标上的汉字是用什么字体显示的，从而确定应该用什么字体显示中文。
另一个有用的函数是 =describe-fontset=

中文用雅黑，英文用consolas比直接用雅黑的混合字体显示效果好。混合字体对一个特定的字体大小显示效果好。
CJK (Chinese, Japanese, Korean)

#+BEGIN_SRC emacs-lisp
;; (if (eq system-type 'windows-nt)
;;   ;(set-fontset-font t 'han (font-spec :family "Microsoft Yahei" :size 12))
;;   ;(setq face-font-rescale-alist '(("微软雅黑" . 1.2) ("Microsoft Yahei" . 1.2)))
;;   (progn
;;     ;; Setting English Font
;;     ;; (set-face-attribute 'default nil :font "Consolas 11")
;;     ;; (set-face-attribute 'default nil :font "Source Code Variable 8")
;;     ;; (set-face-attribute 'default nil :font "Monaco 10")
;;     ;; (set-face-attribute 'default nil :font "Liberation Mono 10")
;;     (set-face-attribute 'default nil :font "Ubuntu Mono 12")
;;     ;; (set-face-attribute 'default nil :font "Fira Code 8")
;;     ;; (set-face-attribute 'default nil :font "Fira Code Retina 10")
;;     ;; (set-face-attribute 'default nil :font "DejaVu Sans Mono 10")
;; 
;;     ;; Chinese Font
;;     (dolist (charset '(kana han symbol cjk-misc bopomofo))
;;             (set-fontset-font (frame-parameter nil 'font)
;;                           charset
;;                           (font-spec :family "Microsoft Yahei" :size 16)))))

(defun albert-notebook-font()
  "Config font on HP zhan66."
  (interactive)
  (if (eq system-type 'windows-nt)
    (progn
      ;; Setting English Font
      (set-face-attribute 'default nil :font "Ubuntu Mono 11")
      ;; Chinese Font
      (dolist (charset '(kana han symbol cjk-misc bopomofo))
              (set-fontset-font (frame-parameter nil 'font)
                            charset
                            (font-spec :family "Microsoft Yahei" :size 22))))))

(defun albert-s2319-font()
  "Config font on dell s2319. 
   Ubuntu Mono 10 + Yahei 14 太小了
   Ubuntu Mono 12 + Yahei 16 比较合适
   "
  (interactive)
  (if (eq system-type 'windows-nt)
    (progn
      ;; Setting English Font
      (set-face-attribute 'default nil :font "Ubuntu Mono 12")
      ;; (set-face-attribute 'default nil :font "Monaco 10")
      ;; (set-face-attribute 'default nil :font "文泉驿等宽正黑 12")
      ;; Chinese Font
      (dolist (charset '(kana han symbol cjk-misc bopomofo))
              (set-fontset-font (frame-parameter nil 'font)
                            charset
                            (font-spec :family "Microsoft Yahei" :size 16))))))
                            ;;(font-spec :family "文泉驿等宽正黑" :size 16))))))

                           
(if (eq window-system 'w32)
  (progn
    ;; 根据显示器实际宽度(以毫米为单位)，显示字体.
    ;; DELL S2319HS 分辨率1920x1080, 屏幕尺寸是509mm X 286mm
    (if (>= (display-mm-width) 509)
      (albert-s2319-font))
    
    ;; 宽度在500mm的认为是笔记本?或者更加精确一点的方式来匹配不同的笔记本型号?
    ;; HP ZHAN66 309mm X 175mm
    ;; Thinkpad T430 4xxmm X 20xmm?
    (if (<= (display-mm-width) 500)
      (albert-notebook-font))))

;; [2018-12-10 周一 11:30:55] 测试了https://github.com/crvdgc/Consolas-with-Yahei
;; 效果不好。
;; (set-default-font "Consolas-with-Yahei 9")

;; (if (eq system-type 'windows-nt)
;;      (set-face-attribute
;;        'default nil :font "Consolas-with-Yahei 11"))
#+END_SRC

[2018-12-10 周一 11:39:52] Consolas 10 + Microsoft Yahei 24 org mode table是可以对齐的，但是中文太大了。
Consolas 8 + Microsoft Yahei 20 org mode table是可以对齐的，但是英文太小了。
默认用Consolas 11 + Microsoft Yahei 20的时候不能对齐。

Source Code Variable 无法和Yahei配合对齐。

[2018-12-10 周一 12:17:01] https://github.com/cstrap/monaco-font 
字体下载 https://raw.githubusercontent.com/todylu/monaco.ttf/master/monaco.ttf
"Monaco 8 + Microsoft Yahei 20" org mode table是可以对齐的，但是英文太小了。
"Monaco 10 + Microsoft Yahei 24" org mode table是可以对齐的，但是中文太大了。

[2018-12-10 周一 13:30:29] https://design.ubuntu.com/font/
"Ubuntu Mono 10 + Microsoft Yahei 20" org mode table是可以对齐的，但是英文太小了。
"Ubuntu Mono 12 + Microsoft Yahei 24" org mode table是可以对齐的，但是中文太大了。
"Ubuntu Mono 11 + Microsoft Yahei 22" org mode table是可以对齐的，字体大小正好。

[2019-01-30 周三 14:28:50] 试了一下文泉驿等宽正黑12 + 文泉驿等宽正黑16，中文字体显示发虚。

** Performace problem

[2014-09-12 09:34:00] 就算这样有时候会很卡，xp下就好多了，怀疑和win7/域用户有关。
如果打开会看见很多QueryBasicInformation这样的调用.

#+BEGIN_SRC emacs-lisp
(if (eq system-type 'windows-nt)
    (setq w32-get-true-file-attributes nil))
#+END_SRC

** UTF-8编码
[2014-09-17 14:59:51]

文件名在emacs使用utf-8的默认编码的时候是乱码，win下指定编码为gbk。
#+BEGIN_SRC emacs-lisp
(prefer-coding-system 'utf-8)

(if (eq system-type 'windows-nt)
  (setq file-name-coding-system 'gbk))

;; for linux terminal
(if (eq system-type 'gnu/linux)
  (progn
    (setq locale-coding-system 'utf-8)
    (set-terminal-coding-system 'utf-8)
    (set-keyboard-coding-system 'utf-8)
    (set-selection-coding-system 'utf-8)))
#+END_SRC

* evil

#+BEGIN_SRC emacs-lisp
(use-package evil
  :ensure t
  :defer t
  :init (evil-mode 1)
  :config 
    (progn
      ;; (eval-after-load 'helm-gtags
      ;;    '(progn
      ;;       (define-key evil-motion-state-map "C-]" 'helm-gtags-find-tag-from-here)))
      (eval-after-load 'ggtags
        '(progn
           (evil-make-overriding-map ggtags-mode-map 'normal)
           ;; force update evil keymaps after ggtags-mode loaded
           (add-hook 'ggtags-mode-hook #'evil-normalize-keymaps)))
      (setq evil-want-visual-char-semi-exclusive t)))
#+end_src

为ggtags修改默认的键绑定，可以用 M-.
https://blog.csdn.net/Levi_Huang/article/details/84288493

[2019-01-01 周二 00:08:18] helm-gtags不能在statusbar上显示tag的值，这点不如ggtags好用。先用ggtags吧。

* helm
[2014-09-16 09:27:15]

;; (require 'helm-config)

#+BEGIN_SRC emacs-lisp
(use-package helm
  :ensure t
  :defer t
  :diminish helm-mode
  ;; :config
  :init
  (progn
    (require 'helm-config)
    (setq helm-candidate-number-limit 100)
    ;; From https://gist.github.com/antifuchs/9238468
    (setq helm-idle-delay 0.0 ; update fast sources immediately (doesn't).
          helm-input-idle-delay 0.01  ; this actually updates things
                                        ; reeeelatively quickly.
          helm-yas-display-key-on-candidate t
          helm-quick-update t
          helm-M-x-requires-pattern nil
          helm-ff-skip-boring-files t)
    (helm-mode))
  :bind (("C-c m" . helm-mini)
         ("C-c n" . helm-mini)
         ("C-x C-b" . helm-buffers-list)
         ("C-x b" . helm-buffers-list)
         ("M-y" . helm-show-kill-ring)
         ("M-x" . helm-M-x)
         ("C-x C-f" . helm-find-files)
         ;; ("C-h a" . helm-apropos)
         ;; ("C-x c o" . helm-occur)
         ;; ("C-x c s" . helm-swoop)
         ;; ("C-x c y" . helm-yas-complete)
         ;; ("C-x c Y" . helm-yas-create-snippet-on-region)
         ;; ("C-x c b" . my/helm-do-grep-book-notes)
         ;; ("<tab>" . 'helm-execute-persistent-action)
         ;; ("C-i" . 'helm-execute-persistent-action)
         ;; ("C-z" . 'helm-select-action)
         ("C-x c SPC" . helm-all-mark-rings)))

;; (use-package helm-config)
;; (helm-mode 1)
;; ;; (global-set-key (kbd "C-c h") 'helm-mini)
;; (global-set-key (kbd "C-c m") 'helm-mini)
;; (global-set-key (kbd "C-c n") 'helm-mini)
;; (global-set-key (kbd "M-x") 'helm-M-x)
;; ;; (global-set-key (kbd "C-c a") 'helm-apropos)
;; (global-set-key (kbd "C-x C-f") 'helm-find-files)

(define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to run persistent action
(define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB works in terminal
(define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z

;setq helm-idle-delay 0.0 ; update fast sources immediately (doesn't).
;          helm-input-idle-delay 0.01  ; this actually updates things
;                                      ; reeeelatively quickly.

;; [2019-01-11 周五 23:48:42]
;; (setq helm-quick-update t
;;       helm-M-x-requires-pattern nil ; 在M-x时默认就不显示多余的pattern了，看着烦
;;       helm-ff-skip-boring-files t)
      
(ido-mode -1)  ;; Turn off ido mode in case I enabled it accidentally
#+END_SRC

** Search buffers by major-mode

+ multi buffer search
  1. *C-c h* 调出helm-mini buffer
  1. 在pattern: 中 输入 *org 选择buffer中的file，可以匹配多个文件
  1. *Esc m* 或者 *M-SPC* mark刚才匹配的files，会高亮
  1. 按 *C-s* search file content
  1. *C-j* 打开buffer并跳到选择的行
  1. *enter* 打开文件

+ M-SPC/Esc-SPC/C-@ :: 用 *M-SPC* 最方便了，mark当前的buffer，如果已经mark了会取消，先C-n/C-p移动到要取消的file

+ M-u :: 取消全部mark的buffer
+ M-a :: mark全部的buffer
     
[2014-09-16 18:24:22] multi search也可以这样，如在所有buffer中org-mode的buffer，然后找 *org @string_to_find 按 *C-s* 就ok了。

+ C-n/C-p/up/down :: 在helm的选项中上下移动
+ left/right :: 在source间移动， *C-o* 移动到下一个source，source就是group分类，如buffer，最近访问的buffer，创建buffer。
+ M-p/M-n :: 命令历史
             
+ mini buffer
  + M-S-d :: kill buffer and quit，就是 *M-D* 。
  + C-c d :: kill buffer without quitting
             
[2014-09-17 15:06:59] 为什么用了heml以后连dired+的 *R* rename file都变成helm的了？

[2014-10-13 周一 17:51:09] helm mini中，选择buffer后，按 =F9= 可以查找，这个更加方便。

** grep

=helm-resume= 恢复上次的command

*** Grep from helm-find-files

From helm-find-files (helm-command-prefix-key C-x C-f) Open the action
menu with tab and choose grep. A prefix arg will launch recursive
grep.

NOTE:You can now launch grep with (C-u) M-g s without switching to the
action pannel.

*** Grep thing at point

Before lauching helm, put your cursor on the start of symbol or sexp
you will want to grep. Then launch helm-do-grep or helm-find-files,
and when in the grep prompt hit C-w as many time as needed.

光标在一个word前面，然后 =helm-do-grep= ，选择grep的目录和文件 ，就可以grep这个word，按 =C-w=
可以跟着grep这个word后面的word。

*** Grep persistent action

As always, C-z will bring you in the buffer corresponding to the file
you are grepping. Well nothing new, but using C-u C-z will record this
place in the mark-ring. So if you want to come back later to these
places, there is no need to grep again, you will find all these places
in the mark-ring. Accessing the mark-ring in Emacs is really
inconvenient, fortunately, you will find in helm-config
helm-all-mark-ring which is a mark-ring browser
(helm-command-prefix-key C-c SPACE). helm-all-mark-ring is in helm
menu also, in the tool section.

TIP: Bind helm-all-mark-ring to C-c SPACE.

在org mode下，无效。
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c <SPC>") 'helm-all-mark-rings)
#+END_SRC

NOTE: helm-all-mark-ring handle global-mark-ring also.

* helm-swoop
[2014-11-21 周五 09:26:34]

#+BEGIN_SRC emacs-lisp
(use-package helm-swoop
  :ensure t
  :defer t
  :bind (("M-i" . helm-swoop)
         ("M-I" . helm-swoop-back-to-last-point)
         ("C-c M-i" . helm-multi-swoop)
         ("C-x M-i" . helm-multi-swoop-all)))
#+END_SRC

* helm-gtags - 不用了 [2018-12-31 周一 23:31:48]

[2019-01-11 周五 22:16:55] 不如ggtags好用，ggtags用着比较习惯。

#+BEGIN_SRC lisp
;; (use-package helm-gtags
;;   :ensure t
;;   :defer t
;;   :init
;;     (setq helm-gtags-ignore-case t
;;           helm-gtags-auto-update t
;;           helm-gtags-use-input-at-cursor t
;;           helm-gtags-pulse-at-cursor t
;;           helm-gtags-prefix-key "\C-cg"
;;           helm-gtags-suggested-key-mapping t))
;; 
;; (defun set-helm-gtags-keybindings ()
;;   (define-key helm-gtags-mode-map (kbd "C-c g a") 'helm-gtags-tags-in-this-function)
;;   (define-key helm-gtags-mode-map (kbd "C-c g s") 'helm-gtags-select)
;;   (define-key helm-gtags-mode-map (kbd "M-."    ) 'helm-gtags-dwim)
;;   (define-key helm-gtags-mode-map (kbd "M-,"    ) 'helm-gtags-pop-stack)
;;   (define-key helm-gtags-mode-map (kbd "C-c g p") 'helm-gtags-previous-history)
;;   (define-key helm-gtags-mode-map (kbd "C-c g n") 'helm-gtags-next-history))
;; 
;; (add-hook 'helm-gtags-mode-hook 'set-helm-gtags-keybindings)
#+END_SRC

* helm-ag [2019-01-01 周二 00:15:53]
https://emacs-china.org/t/emacs-helm-ag/6764/7 如何定位并解决Emacs helm-ag的中文搜索问题

* ggtags [2019-01-01 周二 00:32:00]

| key     | function              | 说明                       |
|---------+-----------------------+----------------------------|
| M-.     | ggtags-find-tag-dwim  | C-] 在evil-mode中 无法bind |
| M-,/C-T | xref-pop-marker-stack | C-T bind的是 pop-tag-mark  |
| M-]     | ggtags-find-reference | 查询调用了tag的reference   |

#+BEGIN_SRC emacs-lisp
(use-package ggtags
  :ensure t
  :defer t)

(add-hook 'c-mode-common-hook
  (lambda ()
    (when (derived-mode-p 'c-mode 'c++-mode 'java-mode 'asm-mode)
      (progn
        ;; (linum-mode 1)
        ;; (flycheck-mode 1)
        (ggtags-mode 1)))))
#+END_SRC

* window-number

和 window-numbering.el 不是一个package。
直接按 *M-num* 就ok，完了，用了这个都忘记怎么切窗口了， ^_^ *C-x o*, *C-x 1*

#+BEGIN_SRC emacs-lisp
(use-package window-numbering
  :ensure t
  ;; :defer t
  :config (window-numbering-mode 1))
  ;; :init (window-numbering-mode 1))
#+END_SRC

* undotree

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :defer t
  :diminish undo-tree-mode
  :config
    (progn
      (global-undo-tree-mode)
      (setq undo-tree-visualizer-timestamps t)
      (setq undo-tree-visualizer-diff t)))

(defalias 'redo 'undo-tree-redo)
;;(global-set-key (kbd "C-z") 'undo) ; 【Ctrl+z】
;;(global-set-key (kbd "C-S-z") 'redo) ; 【Ctrl+Shift+z】;  Mac style
;;(global-set-key (kbd "C-y") 'redo) ; 【Ctrl+y】; Microsoft Windows style
(global-set-key (kbd "C-r") 'redo) ; 【Ctrl+r】; VIM style
#+END_SRC

* python

pdb setup, note the python version
#+BEGIN_SRC lisp
;; (setq pdb-path 'c:/Python/Python36/Lib/pdb.py
;;        gud-pdb-command-name (symbol-name pdb-path))
;;  (defadvice pdb (before gud-query-cmdline activate)
;;    "Provide a better default command line when called interactively."
;;    (interactive
;;     (list (gud-query-cmdline pdb-path
;;                  (file-name-nondirectory buffer-file-name)))))
#+end_src


[2018-11-29 周四 16:15:34]
#+BEGIN_SRC emacs-lisp
;; (setq python-shell-interpreter "python"
(setq python-shell-interpreter "ipython"
      python-shell-interpreter-args "-i --simple-prompt")

;; (use-package python-mode
;;   :mode (("SConstruct\\'" . python-mode)
;;          ("SConscript\\'" . python-mode)
;;          ("\\.py\\'"      . python-mode))
;;   :defer t
;;   ;; [2018-12-01 周六 22:13:10] 为什么execl-test.py不能显示中文doc，而且不停报错?
;;   :init (elpy-enable)
;;   :config
;;   (use-package elpy
;;     :ensure t
;;     :defer t
;;     :init
;;     (progn
;;       ;;(setq elpy-rpc-python-command "python3")
;;       (elpy-use-ipython)
;;       ;; (add-hook 'elpy-mode-hook (lambda () (elpy-shell-toggle-dedicated-shell 1)))
;;       ;; use flycheck not flymake with elpy
;;       ;; (when (require 'flycheck nil t)
;;       ;;   (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
;;       ;;   (add-hook 'elpy-mode-hook 'flycheck-mode))
;;       )))

;; (elpy-enable)

(use-package elpy
  :ensure t
  :defer t
  :init
  (progn
    (advice-add 'python-mode :before 'elpy-enable))
  :config
  (progn
    ;; (setq elpy-rpc-python-command "python3")
    ;; (elpy-use-ipython)
    ;; (add-hook 'elpy-mode-hook (lambda () (elpy-shell-toggle-dedicated-shell 1)))
    ;; use flycheck not flymake with elpy
    (when (require 'flycheck nil t)
      (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
      (add-hook 'elpy-mode-hook 'flycheck-mode))
    ))
#+END_SRC

** autopep8 [2019-05-17 周五 11:29:37]

M-x elpy-config的检查结果

用pip安装autopep8
#+BEGIN_SRC sh
pip install autopep8
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package py-autopep8
  :ensure t
  :defer t
  :init
    (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save))
#+END_SRC

** Flycheck - http://www.flycheck.org
[2019-05-17 周五 14:49:48] 使用flycheck替换默认的flymake。

flycheck是emacs的语法检查工具，用来替换老的flymake，比flymake支持更多的语言，更多的第三方工具。检查python的语法，要先安装flake8。
#+BEGIN_SRC sh
pip install flake8
#+END_SRC

#+BEGIN_SRC lisp
;; (use-package flycheck
;;   :ensure t
;;   :defer t
;;   ;; :init
;;   ;;   (when (require 'flycheck nil t)
;;   ;;     (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
;;   ;;     (add-hook 'elpy-mode-hook 'flycheck-mode)))
;;   )
#+END_SRC

* common setting - 可以推迟启动的
** 去掉启动欢迎界面

#+begin_src emacs-lisp
(setq inhibit-startup-message t) 
#+end_src

** 不要总是没完没了的问yes or no

#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** 不显示工具栏和滚动条
[2014-11-18 周二 17:39:59] 把scrollbar也去掉了

#+begin_src emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)

(if (eq window-system 'w32)
  (scroll-bar-mode -1))
#+end_src

** 光标靠近鼠标的时候，让鼠标自动让开，不挡住视线

#+begin_src emacs-lisp
(mouse-avoidance-mode 'animate)
#+end_src

** Frame title

#+begin_src emacs-lisp
(setq frame-title-format "Albert@%f")
#+end_src

;;(setq frame-title-format "Albert@%b")
** minibuffer
[2014-09-12 09:24:17]

It often displays so much information, even temporarily, that it is nice to give
it some room to breath.

#+BEGIN_SRC emacs-lisp
(setq resize-mini-windows t)
(setq max-mini-window-height 0.33)
#+END_SRC

** Backups
[2014-09-12 09:32:53]

This is one of the things people usually want to change right away. By default, 
Emacs saves backup files in the current directory. These are the files ending in ~ that are cluttering up your directory lists. 
The following code stashes them all in ~/.emacs.d/backups, where I can find them with C-x C-f (find-file) if I really need to.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backup")))

;; 自动存盘
(setq auto-save-mode t) 
#+END_SRC

Disk space is cheap. Save lots.
#+BEGIN_SRC emacs-lisp
(setq delete-old-versions -1)
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
#+END_SRC

** Color theme

emacs24自带的最喜欢的theme。

[2017-04-30 周日 23:55:59] 试了一下solarized，在light mode下不好看，太晃眼，helm不知道选中了哪个，dark mode也一样，org mode中代码的高亮没有了。deeper-blue更好。
#+BEGIN_SRC emacs-lisp
;; (load-theme 'deeper-blue t)
#+END_SRC

;; (load-theme 'solarized t)
;; (load-theme 'tango-dark t)
;; (load-theme 'manoj-dark t)

[2019-01-11 周五 21:55:40] 下面的theme不是用load-theme加载，不如什么theme都不用，纯白的。
;; (load-theme 'Snowish t)
;; (load-theme 'Bharadwaj-Slate t)
;; (load-theme 'Infodoc t)

JB Simple 白底黑字不错
Jedit Grey 灰底黑字也可以

*** doom-themes [2019-05-21 周二 09:19:44]
昨天看了doom-emacs，觉得theme和modeline很漂亮，就试了一下。但是所有的theme的org block都是加亮的，
和现在使用的deeper-blue差异太大，就自己增加了一个theme。

;#+BEGIN_SRC lisp
#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :ensure t
  ;; :disabled t
  :defer t
  :init
  ;; :config
  (progn
    ;; Global settings (defaults)
    (setq doom-themes-enable-bold nil  ; if nil, bold is universally disabled
                                       ; 禁用粗体，否则org-mode的outline字体太难看
          doom-themes-enable-italic t) ; if nil, italics is universally disabled

    ;; 在load-theme之前设置，让modeline更亮一点，
    ;; [2019-05-21 周二 16:54:51] 不知道改了doom-deeper-blue-theme.el的哪个地方，貌似modeline中的文件名能看清楚了。
    (setq doom-deeper-blue-brighter-modeline nil)

    ;; Load the theme (doom-one, doom-molokai, etc); keep in mind that each theme may have their own settings.
    ;; (load-theme 'doom-one t)
    (load-theme 'doom-deeper-blue t)
    
    ;; Enable flashing mode-line on errors
    (doom-themes-visual-bell-config)
    
    ;; Enable custom neotree theme (all-the-icons must be installed!)
    (doom-themes-neotree-config)
    ;; or for treemacs users
    (doom-themes-treemacs-config)
    
    ;; Corrects (and improves) org-mode's native fontification.
    (doom-themes-org-config)))
#+END_SRC
** Diredplus

[2014-09-11 10:47:57] 昨天刚开始用的，五颜六色的比较好看。

[2014-11-18 周二 10:54:56] 为什么在24.4上就不显示时间戳和权限了呢？

set =diredp-hide-details-initially-flag= to nil in 24.4 to display details, set
before dired+ loaded

也可以按 =(= 打开或关闭detail显示。

#+BEGIN_SRC emacs-lisp
(setq diredp-hide-details-initially-flag nil)
(use-package dired+
  :defer t)
#+END_SRC

** 多行代码的注释/反注释

其实可以考虑vim的 =<leader> + \= 进行注释的。
#+BEGIN_SRC emacs-lisp
(global-set-key [?\C-c ?\C-/] 'comment-or-uncomment-region)

(defun my-comment-or-uncomment-region (beg end &optional arg)  
  (interactive (if (use-region-p)  
                   (list (region-beginning) (region-end) nil)  
                   (list (line-beginning-position)  
                       (line-beginning-position 2))))  
  (comment-or-uncomment-region beg end arg)  
)  
(global-set-key [remap comment-or-uncomment-region] 'my-comment-or-uncomment-region)  
#+END_SRC

** ibuffer

使用emacs时经常需要管理多个buffer， /C-x C-b/ 的默认界面太过简陋。emacs事实上已
经提供了更好的buffer管理界面ibuffer，在配置文件中选用即可。

启用ibuffer支持，增强 *buffer*, 用了helm，ibuffer可以退休了。  
#+BEGIN_SRC emacs-lisp
(use-package ibuffer
  :defer t
  :config (global-set-key (kbd "C-x C-b") 'ibuffer))
#+END_SRC

** 字体放大缩小

from sacha chua
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-=") 'text-scale-increase)
(global-set-key (kbd "C--") 'text-scale-decrease)
#+END_SRC

** 显示匹配的括号

#+BEGIN_SRC emacs-lisp
(show-paren-mode t)
#+END_SRC

** 显示行、列号

在status bar显示，不在buffer的左侧显示每行的行号，否则真的会很慢。

列号是从0开始的。
#+BEGIN_SRC emacs-lisp
(column-number-mode t)
#+END_SRC

[2014-03-17 17:54:25] 不显示行号，否则速度会非常慢

#+BEGIN_SRC lisp
;;另外一个显示行号的插件，个人更喜欢的风格
;(require 'linum)
;(global-linum-mode t)
#+END_SRC

[2019-05-15 周三 15:33:55] emacs 26.2可以用，显示速度比linum快很多。
#+BEGIN_SRC emacs-lisp
;; (global-display-line-numbers-mode t)
(setq display-line-numbers-width-start 5)

(add-hook 'org-mode-hook 'display-line-numbers-mode)
(add-hook 'python-mode-hook 'display-line-numbers-mode)
(add-hook 'c-mode-common-hook 'display-line-numbers-mode)
(add-hook 'emacs-lisp-mode-hook 'display-line-numbers-mode)
(add-hook 'sh-mode-hook 'display-line-numbers-mode)
#+END_SRC

** F5插入当前时间
insert current time，要加上(interactive)啊，为什么呢？

#+BEGIN_EXAMPLE
M-: (insert (format-time-string "[%Y-%m-%d %a %T]"))
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
(global-set-key [(f5)] '(lambda () (interactive) 
(insert (format-time-string "[%Y-%m-%d %a %T]"))
))
#+END_SRC

** Reading

https://github.com/xahlee/xah_emacs_init/blob/master/xah_emacs_font.el From Xah Lee:

#+BEGIN_SRC emacs-lisp
(defun xah-toggle-margin-right ()
  "Toggle the right margin between `fill-column' or window width.
This command is convenient when reading novel, documentation."
  (interactive)
  (if (eq (cdr (window-margins)) nil)
      (set-window-margins nil 0 (- (window-body-width) fill-column))
    (set-window-margins nil 0 0)))
#+END_SRC

** Make window splitting more useful

I added these snippets to my .emacs so that when I split the screen with C-x 2 or C-x 3, 
it opens the previous buffer instead of giving me two panes with the same buffer:

Copied from http://www.reddit.com/r/emacs/comments/25v0eo/you_emacs_tips_and_tricks/chldury

#+BEGIN_SRC emacs-lisp
(defun vsplit-last-buffer ()
  (interactive)
  (split-window-vertically)
  (other-window 1 nil)
  (switch-to-next-buffer)
  )
(defun hsplit-last-buffer ()
  (interactive)
   (split-window-horizontally)
  (other-window 1 nil)
  (switch-to-next-buffer)
  )

(global-set-key (kbd "C-x 3") 'vsplit-last-buffer)
(global-set-key (kbd "C-x 2") 'hsplit-last-buffer)
#+END_SRC

** 图片支持
[2014-09-18 08:49:12]

=M-x list-dynamics-libraries= 找到对应的dll的name。

可以运行下面几行代码检查一下是否已经支持了图片。

#+BEGIN_SRC lisp
(image-type-available-p 'gif)

(image-type-available-p 'jpeg)

(image-type-available-p 'tiff)

(image-type-available-p 'xbm)

(image-type-available-p 'xpm)

(image-type-available-p 'png)
#+END_SRC

这几个函数复制到Lisp模式的buffer，然后在每一行行尾按 *C-j* ，就可以看到每个函数运行的结果，返回 *t* 证明已经可以支持图片了。

win的emacs不能显示图片是因为编译后默认没有带几个dll文件。把dll copy到emacs安装目录的bin目录下，就可以显示图片了。

*** emacs 24.4
+ png
  [2014-11-18 周二 15:48:21] emacs 24.4需要libpng16-16.dll or libpng16.dll 和 zlib1.dll，都在libpng的压缩包里面
  可以从 http://sourceforge.net/projects/ezwinports/files/ 下载

*** emacs 24.3
+ png :: libpng14.dll

#+BEGIN_EXAMPLE
jpeg62.dll
libgcrypt-11.dll
libgnutls-26.dll
libpng14-14.dll
libtasn1-3.dll
libtiff3.dll
libungif4.dll
libXpm.dll
xpm4.dll
zlib1.dll
#+END_EXAMPLE

可以从 https://github.com/winterTTr/emacs-of-winterTTr/tree/master/.emacs.d/extra-bin/dlls 下载

** 输入特殊字符
[2014-09-29 周一 17:20:40]

+  :: C-q C-a

+ C-q X :: 是一个通用的输入特殊字符的解决办法，X 表示一个特殊字符， 在几乎所有的模式下，输入 =C-q= 然后是一个就可以输入这个特殊字符。
一般来说、所有的特殊的字符都和某一个特定的函数绑定在一起 了，例如 C-a , ASCII 1 , 表示 beginning-of-line 。 换行的字符就是 C-j ， ASCII 10。
除了输入 C-j ，还可以输入回车字符的 ASCII 的 8 进制数， 例如 C-q 1 2 。 因为 C-j 对应的 ACSII 是 10, 012 八进制 ， 0xA 十六进制。
#+BEGIN_SRC lisp
(setq read-quoted-char-radix 10)
;or
(setq read-quoted-char-radix 16)
#+END_SRC

可以改为把八进制改为十进制或者十六进制。或者用命令
#+BEGIN_EXAMPLE
M-x set-variable <RET> read-quoted-char-radix <RET>10 
#+END_EXAMPLE

** save the cursor position for every file you opened

Turn on save place so that when opening a file, the cursor will be at the last position.
#+BEGIN_SRC emacs-lisp
;; For GNU Emacs 24.5 and older versions
;; (require 'saveplace)
;; (setq save-place-file (concat user-emacs-directory "saveplace.el") ) ; use standard emacs dir
;; (setq-default save-place t)

;; For GNU Emacs 25.1 and newer versions
(setq-default save-place t)
(use-package saveplace
  ;; :ensure t
  :init (save-place-mode 1))
#+END_SRC

** mode-line
*** doom-modeline
[2019-05-21 周二 17:05:01] 其实主要是为了用doom-modeline才修改doom-themes的。
如果不用doom-themes而是使用Emacs的deeper-blue，modeline的前景色会很难看，而且文件名看不清楚。

https://seagle0128.github.io/doom-modeline/ 国人写的，在emacs-china上看见了。

+ 优点
  1. 速度很快
  2. 显示很漂亮
     
+ Install
  1. all-the-icons包和里面的艺术字体，windows上手动安装字体。

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :ensure t
  :defer t)
  
(use-package doom-modeline
  :ensure t
  :defer t
  ;; :init
  :config
  (progn
    ;; How tall the mode-line should be (only respected in GUI Emacs).
    ;; (setq doom-modeline-height 20)
    
    ;; How wide the mode-line bar should be (only respected in GUI Emacs).
    ;; (setq doom-modeline-bar-width 3)

    ;; Whether show `all-the-icons' or not (if nil nothing will be showed).
    (setq doom-modeline-icon t)
    
    ;; Whether show the icon for major mode. It respects `doom-modeline-icon'.
    (setq doom-modeline-major-mode-icon t)
    
    ;; Display color icons for `major-mode'. It respects `all-the-icons-color-icons'.
    (setq doom-modeline-major-mode-color-icon t)
    
    ;; Whether display minor modes or not. Non-nil to display in mode-line.
    (setq doom-modeline-minor-modes nil)
    
    ;; Slow Rendering. If you experience a slow down in performace when rendering multiple icons simultaneously, you can try setting the following variable
    (setq inhibit-compacting-font-caches t)
    
    ;; Whether display `lsp' state or not. Non-nil to display in mode-line.
    (setq doom-modeline-lsp nil)
    
    ;; Whether display mu4e notifications or not. Requires `mu4e-alert' package.
    (setq doom-modeline-mu4e nil)
    
    ;; Whether display irc notifications or not. Requires `circe' package.
    (setq doom-modeline-irc nil)
    )
  :hook (after-init . doom-modeline-mode))
#+END_SRC

*** modeline中的时间格式设置
[2014-11-21 周五 10:35:59]

在modeline上显示日期时间。

;; (setq display-time-24hr-format t)
;; (setq display-time-use-mail-icon t)
;; (setq display-time-interval 60)

#+BEGIN_SRC emacs-lisp
(setq display-time-day-and-date t)
(setq display-time-format "%Y-%m-%d %a %H:%M")
(setq display-time-default-load-average nil)
(display-time)
#+END_SRC

*** 不显示一些无用的minor mode
#+BEGIN_SRC emacs-lisp
(use-package diminish
  :ensure t
  :defer t)

;(eval-after-load "yasnippet" '(diminish 'yas-minor-mode))
;(eval-after-load "undo-tree" '(diminish 'undo-tree-mode))
;(eval-after-load "guide-key" '(diminish 'guide-key-mode))
;(eval-after-load "smartparens" '(diminish 'smartparens-mode))
;(eval-after-load "guide-key" '(diminish 'guide-key-mode))
(eval-after-load "eldoc" '(diminish 'eldoc-mode))
(eval-after-load "org-indent" '(diminish 'org-indent-mode))
(eval-after-load "highlight-parentheses" '(diminish 'highlight-parentheses-mode))
(eval-after-load "auto-revert" '(diminish 'auto-revert-mode))

(diminish 'visual-line-mode)
#+END_SRC

*** smart-mode-line和powerline都不好用，速度太慢。
#+BEGIN_SRC lisp
;; (use-package smart-mode-line
;;   :disabled t
;;   :init
;;   (progn
;;   (setq-default
;;    mode-line-format 
;;    '("%e"
;;      mode-line-front-space
;;      mode-line-mule-info
;;      mode-line-client
;;      mode-line-modified
;;      mode-line-remote
;;      mode-line-frame-identification
;;      mode-line-buffer-identification
;;      "   "
;;      mode-line-position
;;      (vc-mode vc-mode)
;;      "  "
;;      mode-line-modes
;;      mode-line-misc-info
;;      mode-line-end-spaces))))
#+END_SRC

#+BEGIN_SRC lisp
;; (use-package powerline
;;   :disabled t
;;   :ensure t
;;   :config 
;;     (progn
;;        (powerline-center-evil-theme)
;;        (setq powerline-arrow-shape 'arrow)
;;        (custom-set-faces  
;;          '(mode-line ((t (:foreground "white" :background "#8080ff" :box nil))))  
;;          ;; '(mode-line-inactive ((t (:foreground "white" :background "#ff8080" :box nil))))  
;;          )))
;;       ;; (powerline-default-theme)))
;;       ;; (powerline-center-evil-theme)))
#+END_SRC
* scheme [2017-03-02 周四 21:27:47]

;; (require 'cmuscheme)
#+BEGIN_SRC emacs-lisp
  (use-package cmuscheme
    :defer t)
  (setq scheme-program-name "racket")         ;; 如果用 Petite 就改成 "petite"
  ;; (setq scheme-program-name "scheme")         ;; 如果用 Petite 就改成 "petite"

  ;; bypass the interactive question and start the default interpreter
  (defun scheme-proc ()
    "Return the current Scheme process, starting one if necessary."
    (unless (and scheme-buffer
		 (get-buffer scheme-buffer)
		 (comint-check-proc scheme-buffer))
      (save-window-excursion
	(run-scheme scheme-program-name)))
    (or (scheme-get-process)
	(error "No current process. See variable `scheme-buffer'")))

  (defun scheme-split-window ()
    (cond
     ((= 1 (count-windows))
      (delete-other-windows)
      ;; (split-window-vertically (floor (* 0.68 (window-height))))
      (split-window-horizontally (floor (* 0.60 (window-width))))
      (other-window 1)
      (switch-to-buffer "*scheme*")
      (other-window 1))
     ((not (cl-find "*scheme*"
		 (mapcar (lambda (w) (buffer-name (window-buffer w)))
			 (window-list))
		 :test 'equal))
      (other-window 1)
      (switch-to-buffer "*scheme*")
      (other-window -1))))

  (defun scheme-send-last-sexp-split-window ()
    (interactive)
    (scheme-split-window)
    (scheme-send-last-sexp))

  (defun scheme-send-definition-split-window ()
    (interactive)
    (scheme-split-window)
    (scheme-send-definition))

  (add-hook 'scheme-mode-hook
    (lambda ()
      (paredit-mode 1)
      (evil-paredit-mode 1)
      (define-key scheme-mode-map (kbd "<f6>") 'scheme-send-last-sexp-split-window)
      (define-key scheme-mode-map (kbd "<f7>") 'scheme-send-definition-split-window)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; [2017-04-09 周日 00:20:25]
(use-package paren-face
  :ensure t
  :defer t
  :init (global-paren-face-mode 1)
)
#+END_SRC
* web-mode [2018-02-08 周四 17:03:42]

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :defer t)
#+END_SRC
* markdown-mode

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  ;; :ensure t
  :defer t
  :commands (markdown-mode gfm-mode)
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init (setq markdown-command "multimarkdown"))
#+END_SRC
  
* xah-find [2018-09-29 周六 22:09:48]
http://ergoemacs.org/emacs/elisp-xah-find-text.html

1. evil mode下按tab和enter都不能跳转到文件对应的地方，只能用鼠标，除非是emacs mode下。
2. 不知道是怎么找的扩展名，如果打开一个 *.te的文件，默认扩展名就是 *.te，改改?

#+BEGIN_SRC emacs-lisp
(use-package xah-find
  :ensure t
  :defer t)
#+END_SRC

* emacs-lisp
[2014-09-27 01:58:44]

lisp语言入门，写得很不错，找不到原出处了 http://www.cnblogs.com/suiqirui19872005/archive/2007/12/05/984517.html

emacs自带的帮助也不错，可以了解emacs lisp的特点，和common lisp的区别慢慢体会。

** 括号高亮
http://www.emacswiki.org/emacs/HighlightParentheses

http://ergoemacs.org/emacs/emacs_editing_lisp.html

#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook
          '(lambda ()
             (highlight-parentheses-mode)))

(define-globalized-minor-mode global-highlight-parentheses-mode
  highlight-parentheses-mode
  (lambda ()
    (highlight-parentheses-mode t)))
(global-highlight-parentheses-mode t)
#+END_SRC

** eldoc-mode
http://sachachua.com/blog/2014/06/read-lisp-tweak-emacs-beginner-24-understand-emacs-lisp-code/

turns on eldoc-mode, which displays the argument list for the current function. 
You can move your cursor around to see argument lists for other functions.
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
#+END_SRC

* magit
[2014-09-11 10:22:26] disable emacs自带的vc，用 *process monitor* 看，vc每次打开都会把支持的版本管理都查一遍，会比较慢。
但是去掉了以后，magit没法在status bar上显示文件在哪个branch上了。哎。

process monitor在用了vpn后会导致机器hang。

把vc disable后会快不少，还是去了吧。

#+BEGIN_SRC lisp
;; (custom-set-variables
;; '(vc-handled-backends (quote (Git))))

;; disable default vc
;(setq vc-handled-backends nil)
#+end_src

[2014-09-11 14:25:06] 即使更新到了0908的magit，仍然发现有多次调用git.exe的情况， *magit-status* 还是慢
把git的path设置到最前面，貌似速度也没快多少，最多0.001s吧。

;;(if (eq system-type 'windows-nt)
;;    (progn
;;      (setq exec-path (add-to-list 'exec-path "C:/Program Files/Git/bin"))
;;      (setenv "PATH" (concat "C:\\Program Files\\Git\\bin;" (getenv "PATH")))))

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :defer t
  :config
    (progn
      (setq magit-last-seen-setup-instructions "1.4.0")))
#+end_src

* tramp on windows [2018-12-28 周五 11:14:58]

+ new session
  /plink:user@host:/path/to/your/file/on/server

+ saved session
  /plinkx:sessname:/path/to/your/file/on/server
  
+ 不需要设置 tramp-shell-prompt-pattern 和 tramp-password-end-of-line 。
+ plink要在PATH里有。

[2019-06-08 周六 01:44:30] tramp在windows上没法用，连虚机都能感觉到实在是太卡了。
#+BEGIN_SRC lisp
(use-package tramp
  :defer t
  :config
    (progn
      (setq exec-path (cons "E:/tools/putty" exec-path))
      ;; (setq tramp-password-end-of-line "\r\n")
      ;; (setq tramp-shell-prompt-pattern "^[ $]# +")
      (setq tramp-ssh-controlmaster-options "-o ControlMaster=auto -o ControlPath='tramp.%%C' -o ControlPersist=no")
      (setq tramp-default-method "plink")))
#+END_SRC
* c-mode coding style [2019-01-05 周六 11:20:13]

emacs使用google-c-style
google c++编码规范很全面，现在已经逐渐习惯了这种编码规范，突然想到或许emacs中有合适的el支持这种规范，到网上一找，果然有。

http://google-styleguide.googlecode.com/svn/trunk/google-c-style.el

elpa中安装就可以了。

下载下来，放在emacs.d目录下，然后在.emacs配置文件中添加几行：

(add-to-list 'load-path (expand-file-name "~/.emacs.d"))
(require 'google-c-style)
(add-hook 'c-mode-common-hook 'google-set-c-style)
(add-hook 'c-mode-common-hook 'google-make-newline-indent)

(add-hook 'c-mode-common-hook
          (lambda ()
            (setq c-default-style "k&r" c-basic-offset 4)
            (c-set-offset 'substatement-open 0)))

#+BEGIN_SRC emacs-lisp

(setq c-default-style "linux")
(setq c-basic-offset 4)

(setq default-tab-width 4)
(setq-default indent-tabs-mode nil)

;; (setq tab-width 4)
;; (setq tab-stop-list ())
#+END_SRC

** flycheck在虚机中的配置 [2019-05-24 周五 14:39:51]
在笔记本上就不配置c-mode的flycheck了，没有gcc。add-hook在ggtags的配置里面enable了flycheck-mode。
#+BEGIN_SRC lisp
;; 在目录中建 .dir-locals.el
((c-mode . ((flycheck-gcc-include-path . (;; list
                                          ;; (expand-file-name "~/tengine")
                                          "/home/albert/tengine/src/"
                                          "/home/albert/tengine/src/core/")))))
#+END_SRC

* graphviz [2019-01-08 周二 18:13:47]

主要思想是解析 =buffer= 中选中的文本，通过正则表达式来匹配，从中找到 struct name 以及其中的各个 fields， 最后根据 =dot= 语法将其组成一个 =subgraph= 。其实应该有更好的方法（比如通过 CEDET 的 Semantic 解析结果来做），但对 CEDET 的代码实在不熟，所以现在就只能这样了。
#+BEGIN_SRC emacs-lisp
;; Function used to add fields of struct into a dot file (for Graphviz).
(defconst yyc/dot-head "subgraph cluster_%s {
    node [shape=record fontsize=12 fontname=Courier style=filled];
    color = lightgray;
    style=filled;
    label = \"Struct %s\";
    edge[color=\"#2e3436\"];"
  "Header part of dot file.")

(defconst yyc/dot-tail "
}"
  "Tail part of dot")

(defconst yyc/dot-node-head
  "
        node_%s[shape=record label=\"<f0>*** STRUCT %s ***|\\"
  "Format of node.")

(defconst yyc/dot-node-tail "
\"];"
  "Format of node.")
 
(defconst r_attr_str "[ \t]+\\(.*+\\)[ \t]+\\(.*\\)?;"
  "Regular expression for matching struct fields.")
 
;; (defconst r_name (caar (semantic-parse-region start end))
(defconst r_name "\\_<\\(typedef[ \t]+\\)?struct[ \t]+\\(.*\\)?[ \t]*{"
  "Regular expression for mating struct name")
 
(defconst attr_str "
<f%d>%s %s\\l|\\" "nil")
 
(defun yyc/datastruct-to-dot (start end)
  "generate c++ function definition and insert it into `buffer'"
  (interactive "rp")
  (setq var-defination (buffer-substring-no-properties start end))
  (let* ((tmp_str "")
         (var-name "")
         (var-type "")
         (counter 0)
         (struct-name "")
         (header-str ""))
    (defun iter (pos)
      (setq counter (+ counter 1))
      (message (format "Counter: %d, pos: %d"
                       counter pos))
      (if (string-match r_name var-defination pos)
          (progn
            (message "A")
            (setq struct-name
                  (match-string 2 var-defination))
            ;; (setq struct-name (caar (semantic-parse-region start end)))
            (setq header-str
                  (format yyc/dot-head struct-name struct-name))
            (setq tmp_str
                  (format yyc/dot-node-head struct-name struct-name))
            (iter (match-end 0)))
        (if (string-match r_attr_str var-defination pos)
            (progn
              (message "B")
              (setq var-type
                    (match-string 1 var-defination))
              (setq var-name
                    (match-string 2 var-defination))
              (setq tmp_str
                    (concat tmp_str
                            (format attr_str counter var-type var-name)))
              (iter (match-end 0)))
          nil)))
    (save-excursion
      (iter 0)
      (set-buffer (get-buffer-create "tmp.dot"))
      ;;(graphviz-dot-mode)
      (setq pos (point-max))
      (insert  header-str tmp_str )
      (goto-char (point-max))
      (delete-char -1)
      (insert "<f999>\\"yyc/dot-node-tail yyc/dot-tail)
      )
    (if (one-window-p)
        (split-window-vertically))
    (switch-to-buffer-other-window "tmp.dot")
    (goto-char (point-min))
    )
  (message "Finished, please see *tmp.dot* buffer.")
  )
#+END_SRC

使用方法
用起来很简单：找到一个 C 代码，标记整个 struct 定义，然后M-x 输入： yyc/datastruct-to-dot 即可。命令执行完毕后，会打开一个新的 tmp.dot buffer，其中包含了用于绘制该 struct 的代码。前面也提到了，这生成的仅仅是个 subgraph，需要将这个 subgraph 添加到真正的 graph 下，才能生成图像。我通过 autoinsert 来自动创建用于放置 subgraph 的 graph 。

** autoinsert配置
autoinsert 是 Emacs 自带的功能，稍加配置即可使用：

#+BEGIN_SRC emacs-lisp
;; ************** Autoinsert templates *****************
(use-package autoinsert
  :defer t)

(setq auto-insert-mode t)  ;;; Adds hook to find-files-hook
(setq auto-insert-directory "~/.emacs.d/templates/auto-insert/")
(setq auto-insert 'other)
(setq auto-insert-query nil)
 
;; auto-insert stuff
(add-hook 'find-file-hooks 'auto-insert)
(setq auto-insert-alist
      '(
        ("\\.cpp$" . ["insert.cpp" auto-update-c-source-file])
        ("\\.h$"   . ["header.h" auto-update-header-file])
        ("\\.c$" . ["insert.c" auto-update-c-source-file])
        ("\\.org$" . ["insert.org" auto-update-defaults])
        ("\\.sh$" . ["insert.sh" auto-update-defaults])
        ("\\.lisp$" . ["insert.lisp" auto-update-defaults])
        ("\\.el$" . ["insert.el" auto-update-defaults])
        ("\\.dot$" . ["insert.dot" auto-update-defaults])
        ("\\.erl$" . ["insert.err" auto-update-defaults])
        ("\\.py$" . ["insert.py" auto-update-defaults])
        ("\\.tex$" . ["insert.tex" auto-update-defaults])
        ("\\.html$" . ["insert.html" auto-update-defaults])
        ("\\.devhelp2$" . ["insert.devhelp2" auto-update-defaults])
        ("\\.ebuild$" . ["insert.ebuild" auto-update-defaults])
        ("\\.sh$" . ["insert.sh" auto-update-defaults])
        ("Doxyfile$" . ["insert.doxyfile" auto-update-defaults])
        ))
 
;; function replaces the string '@@@' by the current file
;; name. You could use a similar approach to insert name and date into
;; your file.
(defun auto-update-header-file ()
  (save-excursion
    (while (search-forward "@@@" nil t)
      (save-restriction
        (narrow-to-region (match-beginning 0) (match-end 0))
        (replace-match (upcase (file-name-nondirectory buffer-file-name)))
        (subst-char-in-region (point-min) (point-max) ?. ?_)
        ))))
 
(defun insert-today ()
  "Insert today's date into buffer"
  (interactive)
  (insert (format-time-string "%m-%e-%Y" (current-time))))
 
(defun auto-update-c-source-file ()
  (save-excursion
    ;; Replace HHHH with file name sans suffix
    (while (search-forward "HHHH" nil t)
      (save-restriction
        (narrow-to-region (match-beginning 0) (match-end 0))
        (replace-match (concat (file-name-sans-extension (file-name-nondirectory buffer-file-name)) ".h") t)
        )))

  (save-excursion
    ;; Replace @@@ with file name
    (while (search-forward "@@@" nil t)
      (save-restriction
        (narrow-to-region (match-beginning 0) (match-end 0))
        (replace-match (file-name-nondirectory buffer-file-name))
        )))
  (save-excursion
    ;; replace DDDD with today's date
    (while (search-forward "DDDD" nil t)
      (save-restriction
        (narrow-to-region (match-beginning 0) (match-end 0))
        (replace-match "")
        (insert-today)
        ))))
 
(defun auto-replace-file-name ()
  (save-excursion
    ;; Replace @@@ with file name
    (while (search-forward "(>>FILE<<)" nil t)
      (save-restriction
        (narrow-to-region (match-beginning 0) (match-end 0))
        (replace-match (file-name-nondirectory buffer-file-name) t)
        ))
    ))
 
(defun auto-update-defaults ()
  (auto-replace-file-name)
  (auto-replace-file-name-no-ext)
  (auto-replace-date-time))
 
(defun auto-replace-file-name-no-ext ()
  (save-excursion
    ;; Replace @@@ with file name
    (while (search-forward "(>>FILE_NO_EXT<<)" nil t)
      (save-restriction
        (narrow-to-region (match-beginning 0) (match-end 0))
        (replace-match (file-name-sans-extension (file-name-nondirectory buffer-file-name)) t)
        ))))
 
(defun auto-replace-date-time ()
  (save-excursion
    (while (search-forward "(>>DATE<<)" nil t)
      (save-restriction
        (narrow-to-region (match-beginning 0) (match-end 0))
        (replace-match "" t)
        (insert-today)
        ))))
#+END_SRC

模板文件存放于 “~/.emacs.d/templates/auto-insert/” 中，其中， insert.dot 的内容如下：

// $Id: (>>FILE<<), (>>DATE<<)
digraph Name {
    node [shape=record fontsize=12 fontname=Courier style=filled];
    edge[color=blue];
    rankdir=LR;

// XXX: place to put subgraph
}

** 用法示例
一个简单的使用示例，有如下步骤：

1: 打开一个 C 文件

   如内核代码中的 drivers/usb/storage/usb.h

2: 打开一个 dot 文件(/tmp/usb.dot)

   auto-insert 会自动插入一些文件内容.

3: 选中 struct us_data 的定义，并执行 yyc/datastruct-to-dot。

   执行完成后， us_data 的数据填写到了 tmp.dot 中，将该 buffer 中的所有内容 kill 掉，并 yank 到 usb.dot 中 XXX 这一行的下面。此时，保存 sub.dot ， 并按下快捷键 : C-cc ， 然后按下 Enter ， 就会自动编译。然后再按下 C-cp 就可以在另外一个 buffer 中预览它了。

   其实到这里，一个 C 语言的 struct 数据结构就已经被画出来了，后面的两个步骤，是为了介绍怎样将多个数据结构联系起来。

4: 添加其他的subgraph 

   我们可以继续添加其他的subgraph， 例如 struct usb_ctrlrequest *cr ，以及 struct usb_sg_request， 并全部做为 subgraph 添加到 usb.dot 中。

5: 为 subgraph 建立关联

   很简单，通过 “->” 画两条线就可以了。

** semantic [2019-01-08 周二 20:47:56]
https://segmentfault.com/a/1190000004910645?utm_source=tuicool&utm_medium=referral [译] Emacs Lisp 速成

                ;; 这样写不太好看
                 ;; (if (eq function-pointer t)
                 ;;     (setq str (var-str str index type))
                 ;;   (setq str (concat str (format "%s " (semantic-tag-name type)))))))

#+BEGIN_SRC emacs-lisp
(defun albert/datastruct-member (tag)
  "parse tag generated by semantic-parse-region."

  (defun fp-str (str ftag)
    "function pointer args to str. 函数指针参数的处理.如ngx_tcp_module_t里的函数指针"
    (cond
      ((null ftag) "")
      ((cond
         ((semantic-tag-p ftag)
           (let* ((name (semantic-tag-name ftag))
                  (type (semantic-tag-get-attribute ftag :type))
                  (pointer (semantic-tag-get-attribute ftag :pointer)))
             (cond
               ((atom type) (setq str (concat str (format "%s " type))))
               ((semantic-tag-p type) 
                 (setq str (concat str (format "%s " (semantic-tag-name type))))))
 
             (if (numberp pointer)
               (setq str (concat str (make-string pointer ?*))))

             (setq str (concat str (format "%s, " name)))
             ))
         (t (setq str (concat (fp-str str (car ftag)) (fp-str str (cdr ftag)))))
         ))
    ))

  (defun var-str (str index vtag)
    (setq str (format "    <f%d>" index))
    (cond
      ((null vtag) "")
      ((cond
         ((semantic-tag-p vtag)
           (let* ((name (semantic-tag-name vtag))
                  (type (semantic-tag-get-attribute vtag :type))
                  ;;(function-pointer (semantic-tag-get-attribute vtag :function-pointer))
                  (pointer (semantic-tag-get-attribute vtag :pointer)))
             (cond
               ((atom type) (setq str (concat str (format "%s " type))))
               ;; 函数指针要单独处理,如ngx_tcp_module_t里的函数指针
               ((semantic-tag-p type) 
                 (setq str (concat str (format "%s " (semantic-tag-name type))))))
 
             (if (numberp pointer)
               (setq str (concat str (make-string pointer ?*))))

             (if (semantic-tag-get-attribute vtag :function-pointer)
                 (let* ((tmp (fp-str "" (semantic-tag-components vtag)))
                        (args (substring tmp 0 (- (length tmp) 2))))
                       (setq str (format "%s(*%s)(%s) \\l|\\\n" str name args)))
               (concat str (format "%s \\l|\\\n" name)))
             ))
       (t (concat (var-str str (+ index 1) (car vtag)) (var-str str (+ index 1) (cdr vtag))))
         ))
      ))
  (var-str "" 0 tag))
  
(defun albert/datastruct-dot-head (tag)
  "datastruct name to dot head."
  (let ((name (semantic-tag-name tag)))
    (format "subgraph cluster_%s {
  node [shape=record fontsize=12 fontname=Courier style=filled];
  color=lightgray;
  style=filled;
  label = \"Struct %s\";
  edge[color=\"#2e3436\"];
  node_%s [shape=record label=\"\n" name name name)))
  
(defun albert/datastruct-dot-end (str)
  "datastruct to dot end string. 去掉最后一个字段的\l|\n"
  (concat (substring str 0 (- (length str) 3)) "\"];
}\n"))

(defun albert/semantic-lex-buffer (start end)
  "parse c datastruct definition using semantic and insert it into `buffer'"
  (interactive "rp")
  (message "start=%d, end=%d" start end)
  (let* ((tag (car (semantic-parse-region start end)))
         (members (plist-get (semantic-tag-class (semantic-tag-get-attribute tag :typedef)) :members)))
    ;; (message "%s\n" tag)
    ;;(message "%s" (albert/datastruct-dot-head tag))
    ;; (message "%s" (albert/datastruct-member (semantic-tag-components tag)))
    (let* ((body (albert/datastruct-member (semantic-tag-components tag)))
           (dot_str (albert/datastruct-dot-end body)))
      ;;(message "%s" (albert/datastruct-dot-end body))
      (save-excursion
        ;;(iter 0)
        (set-buffer (get-buffer-create "tmp.dot"))
        ;;(graphviz-dot-mode)
        (setq pos (point-max))
        (insert (albert/datastruct-dot-head tag) 
                dot_str)
        (goto-char (point-max))
        (delete-char -1)
      )

      (if (one-window-p)
        (split-window-vertically))

      (switch-to-buffer-other-window "tmp.dot")
      (goto-char (point-min))
    )))

     ;; (plist-get (nthcdr 2 (semantic-tag-get-attribute tag :typedef)) :members))

  ;; (message (semantic-parse-region start end 1)))
  ;; (message (semantic-c-lexer start end 1)))
  ;; (message (semantic-lex-buffer)))
  ;;(semantic-lex start end 1))


#+END_SRC
* winner-mode [2019-01-09 周三 18:04:05]
winner-mode是emacs自带，打开(winner-mode t)之后，就可以用 =C-x <left>= 和 =C-x <right>= 来对窗口布局实现undo/redo了。

#+BEGIN_SRC emacs-lisp
(use-package winner
  :defer t)
 
;; (winner-mode t)
#+END_SRC
* GDB [2019-01-11 周五 21:23:16]

M-x gdb

+ file 打开执行文件
+ l (list): 从第一行开始列出源码，默认10行。
+ b (break):  b <行号> ， b <函数名>
+ r (run): 开始运行调试器，或重新开始运行调试器
+ c (continue): 继续运行到下一个断点，或运行到程序结束
+ clear : clear <行号> ，删除特定行的断点
+ d (delete): d <断点编号>，删除特定编号的断点
+ n (next): 单步执行下一行，如果本行有函数调用，不进入函数
+ s (step): 单步执行下一行，如果本行有函数调用，进入函数
+ until： 结束当前循环
+ p (print): p <变量名>， 显示变量内容
+ whatis： whatis<变量名>，显示变量类型
+ info： info b， 显示断点信息。 info r 显示寄存器信息。 info local 显示当前函数中的局部变量信息。info prog 显示被调试程序的执行状态。
+ p *array@len : 打印一维数组
+ p **array@len : 打印二维数组
+ quit： 退出调试器。

emacs默认的gdb-many-windows有6个调试窗口，有些不常用的，比如断点信息窗等，简化为4个。其实都有用。不改了。

#+BEGIN_SRC lisp
;; set gdb multi-windows when open

;;(setq gdb-many-windows t)

;; customize the gdb multi-windows
;; (defadvice gdb-setup-windows (after my-setup-gdb-windows activate)
;;   "My GDB UI"
;;   (gdb-get-buffer-create 'gdb-stack-buffer)
;;   (set-window-dedicated-p (selected-window) nil)
;;   (switch-to-buffer gud-comint-buffer)
;;   (delete-other-windows)
;;   (let ((win0 (selected-window))
;;         (win1 (split-window nil nil 'left))  ;; code and output
;;         (win2 (split-window-below (/ (* (window-height) 3) 4)))  ;; stack
;;         )
;;     (select-window win2)
;;     (gdb-set-window-buffer (gdb-stack-buffer-name))
;;     (select-window win1)
;;     (set-window-buffer
;;      win1
;;      (if gud-last-last-frame
;;          (gud-find-file (car gud-last-last-frame))
;;        (if gdb-main-file
;;            (gud-find-file gdb-main-file)
;;          ;; Put buffer list in window if we
;;          ;; can't find a source file.
;;          (list-buffers-noselect))))
;;     (setq gdb-source-window (selected-window))
;;     (let ((win3 (split-window nil (/ (* (window-height) 3) 4))))  ;; io
;;       (gdb-set-window-buffer (gdb-get-buffer-create 'gdb-inferior-io) nil win3))
;;     (select-window win0)
;;     ))
#+END_SRC
* neotree [2019-05-27 周一 16:05:25]

#+BEGIN_SRC emacs-lisp
(add-hook 'neotree-mode-hook
            (lambda ()
              (define-key evil-normal-state-local-map (kbd "TAB") 'neotree-enter)
              (define-key evil-normal-state-local-map (kbd "SPC") 'neotree-enter)
              (define-key evil-normal-state-local-map (kbd "q") 'neotree-hide)
              (define-key evil-normal-state-local-map (kbd "RET") 'neotree-enter)))
#+END_SRC
* 现在没用的配置
** 反显选中区域

emacs 23以后默认。
#+begin_src lisp
;(transient-mark-mode t) 
#+end_src
** Mode line format
[2014-09-16 18:18:58]

Display a more compact mode line.

#+BEGIN_SRC lisp
;(use-package smart-mode-line
;(defun my-line()
;  :init
;  (progn
;  (setq-default
;   mode-line-format 
;   '("%e"
;     mode-line-front-space
;     mode-line-mule-info
;     mode-line-client
;     mode-line-modified
;     mode-line-remote
;     mode-line-frame-identification
;     mode-line-buffer-identification
;     "   "
;     mode-line-position
;     (vc-mode vc-mode)
;     "  "
;     mode-line-modes
;     mode-line-misc-info
;     mode-line-end-spaces))))
;(my-line)
#+END_SRC
** ido

#+BEGIN_SRC lisp
;(require 'ido)
#+END_SRC

** smex
[2014-09-19 14:44:30] 有helm，不用smex了。

Smex is a M-x enhancement for Emacs. Built on top of IDO, it provides a convenient interface 
to your recently and most frequently used commands. And to all the other commands, too.

Extras: Limit commands to those relevant to the active major mode. Show frequently used commands that have no key bindings.

用了smex后，现在已经把command忘记得差不多了，现在magit的话，就会 *M-x magit* 直接联想了。呵呵。

#+BEGIN_SRC lisp
;(require 'smex)
;
;(global-set-key (kbd "M-x") 'smex)
;(global-set-key (kbd "M-X") 'smex-major-mode-commands)
;; This is your old M-x.
;;(global-set-key (kbd "C-c C-c M-x") 'execute-extended-command)
#+END_SRC
** htmlize

为了让org mode中的代码可以语法高亮，不知道新的org 8.2.7c是不是自带了，那就可以不用这个了。

#+BEGIN_SRC lisp
;(require 'htmlize)
#+END_SRC

** ace-jump [2014-11-20 周四 18:09:04]

#+BEGIN_SRC lisp
;;;
;;; ace jump mode major function
;;; 
;(autoload
;  'ace-jump-mode
;  "ace-jump-mode"
;  "Emacs quick move minor mode"
;  t)
;;; you can select the key you prefer to
;(define-key global-map (kbd "C-c SPC") 'ace-jump-mode)
;
;;; 
;;; enable a more powerful jump back function from ace jump mode
;;;
;(autoload
;  'ace-jump-mode-pop-mark
;  "ace-jump-mode"
;  "Ace jump back:-)"
;  t)
;(eval-after-load "ace-jump-mode"
;  '(ace-jump-mode-enable-mark-sync))
;(define-key global-map (kbd "C-x SPC") 'ace-jump-mode-pop-mark)
;
;;;If you use evil
;(define-key evil-normal-state-map (kbd "SPC") 'ace-jump-mode)
#+END_SRC 

