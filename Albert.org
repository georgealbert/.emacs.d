
* basic setting
** elpa

#+BEGIN_SRC emacs-lisp
(require 'package)
(add-to-list 'package-archives
  '("melpa" . "http://melpa.org/packages/") t)

(package-initialize)
;(setq package-user-dir (concat dotfiles-dir "/elpa"))

(setq use-package-verbose t)
(require 'use-package)
#+end_src

代理配置
;(setq url-proxy-services
;   '(("no_proxy" . "^\\(localhost\\|10.*\\)")
;     ("http" . "134.80.3.27:8080")
;     ("https" . "134.80.3.27:8080")))

** HOME
设置默认工作目录到HOME目录，不设置的话是 /emacs安装目录/bin/ 。

#+BEGIN_SRC emacs-lisp
(setq default-directory "~/")
#+END_SRC

** Window size

T430的屏幕长了一点，要是全屏的话，org mode的buffer会在右边打开，看见的内容太少了，
控制窗口大小，让buffer显示在下面。

#+BEGIN_SRC emacs-lisp
;; adjust the size of Emacs window for org mode agenda/todo list to display herizontal
(if (eq system-type 'windows-nt)
  ;; (setq default-frame-alist '((top . 0) (left . 0) (height . 42) (width . 159)))
  (toggle-frame-maximized)

  ;; "Maximize emacs window in windows os" WM_SYSCOMMAND #xf030 maximize  
  ;; [2018-09-07 周五 09:53:36] 不知道为什么没有效果
  ;; (interactive)
  ;; (w32-send-sys-command 61488)
)
#+END_SRC

** Font setting on win7/win10

可以用 C-u C-x = or C-u g a 来看当前汉字是用什么字体显示的，从而决定应该在这个变量里加什么。
另一个有用的函数是 =describe-fontset=

中文用雅黑，英文用consolas比直接用雅黑的混合字体显示效果好。混合字体针对一个特定的字体大小。
#+BEGIN_SRC emacs-lisp
;; (if (eq system-type 'windows-nt)
;;   ;(set-fontset-font t 'han (font-spec :family "Microsoft Yahei" :size 12))
;;   ;(setq face-font-rescale-alist '(("微软雅黑" . 1.2) ("Microsoft Yahei" . 1.2)))
;;   (progn
;;     ;; Setting English Font
;;     ;; (set-face-attribute 'default nil :font "Consolas 11")
;;     ;; (set-face-attribute 'default nil :font "Source Code Variable 8")
;;     ;; (set-face-attribute 'default nil :font "Monaco 10")
;;     ;; (set-face-attribute 'default nil :font "Liberation Mono 10")
;;     (set-face-attribute 'default nil :font "Ubuntu Mono 12")
;;     ;; (set-face-attribute 'default nil :font "Fira Code 8")
;;     ;; (set-face-attribute 'default nil :font "Fira Code Retina 10")
;;     ;; (set-face-attribute 'default nil :font "DejaVu Sans Mono 10")
;; 
;;     ;; Chinese Font
;;     (dolist (charset '(kana han symbol cjk-misc bopomofo))
;;             (set-fontset-font (frame-parameter nil 'font)
;;                           charset
;;                           (font-spec :family "Microsoft Yahei" :size 16)))))

(defun albert-notebook-font()
  "Config font on HP zhan66."
  (interactive)
  (if (eq system-type 'windows-nt)
    (progn
      ;; Setting English Font
      (set-face-attribute 'default nil :font "Ubuntu Mono 11")
      ;; Chinese Font
      (dolist (charset '(kana han symbol cjk-misc bopomofo))
              (set-fontset-font (frame-parameter nil 'font)
                            charset
                            (font-spec :family "Microsoft Yahei" :size 22))))))

(defun albert-s2319-font()
  "Config font on dell s2319. 
   Ubuntu Mono 10 + Yahei 14 太小了
   Ubuntu Mono 12 + Yahei 16 比较合适
   "
  (interactive)
  (if (eq system-type 'windows-nt)
    (progn
      ;; Setting English Font
      (set-face-attribute 'default nil :font "Ubuntu Mono 12")
      ;; Chinese Font
      (dolist (charset '(kana han symbol cjk-misc bopomofo))
              (set-fontset-font (frame-parameter nil 'font)
                            charset
                            (font-spec :family "Microsoft Yahei" :size 16))))))

                           
(if (eq window-system 'w32)
  (progn
    ;; 根据显示器实际宽度(以毫米为单位)，显示字体.
    ;; DELL S2319HS 分辨率1920x1080, 屏幕尺寸是509mm X 286mm
    (if (>= (display-mm-width) 509)
      (albert-s2319-font))
    
    ;; 宽度在500mm的认为是笔记本?或者更加精确一点的方式来匹配不同的笔记本型号?
    ;; HP ZHAN66 309mm X 175mm
    ;; Thinkpad T430 4xxmm X 20xmm?
    (if (<= (display-mm-width) 500)
      (albert-notebook-font))))

;; [2018-12-10 周一 11:30:55] 测试了https://github.com/crvdgc/Consolas-with-Yahei
;; 效果不好。
;; (set-default-font "Consolas-with-Yahei 9")

;; (if (eq system-type 'windows-nt)
;;      (set-face-attribute
;;        'default nil :font "Consolas-with-Yahei 11"))
#+END_SRC

[2018-12-10 周一 11:39:52] Consolas 10 + Microsoft Yahei 24 org mode table是可以对齐的，但是中文太大了。
Consolas 8 + Microsoft Yahei 20 org mode table是可以对齐的，但是英文太小了。
默认用Consolas 11 + Microsoft Yahei 20的时候不能对齐。

Source Code Variable 无法和Yahei配合对齐。

[2018-12-10 周一 12:17:01] https://github.com/cstrap/monaco-font 
字体下载 https://raw.githubusercontent.com/todylu/monaco.ttf/master/monaco.ttf
"Monaco 8 + Microsoft Yahei 20" org mode table是可以对齐的，但是英文太小了。
"Monaco 10 + Microsoft Yahei 24" org mode table是可以对齐的，但是中文太大了。

[2018-12-10 周一 13:30:29] https://design.ubuntu.com/font/
"Ubuntu Mono 10 + Microsoft Yahei 20" org mode table是可以对齐的，但是英文太小了。
"Ubuntu Mono 12 + Microsoft Yahei 24" org mode table是可以对齐的，但是中文太大了。
"Ubuntu Mono 11 + Microsoft Yahei 22" org mode table是可以对齐的，字体大小正好。

** Performace problem

[2014-09-12 09:34:00] 就算这样有时候会很卡，xp下就好多了，怀疑和win7/域用户有关。
如果打开会看见很多QueryBasicInformation这样的调用.

#+BEGIN_SRC emacs-lisp
(if (eq system-type 'windows-nt)
    (setq w32-get-true-file-attributes nil))
#+END_SRC

** UTF-8编码
[2014-09-17 14:59:51]

文件名在emacs使用utf-8的默认编码的时候是乱码，win下指定编码为gbk。
#+BEGIN_SRC emacs-lisp
(prefer-coding-system 'utf-8)

(if (eq system-type 'windows-nt)
  (setq file-name-coding-system 'gbk))

;; for linux terminal
(if (eq system-type 'gnu/linux)
  (progn
    (setq locale-coding-system 'utf-8)
    (set-terminal-coding-system 'utf-8)
    (set-keyboard-coding-system 'utf-8)
    (set-selection-coding-system 'utf-8)))
#+END_SRC

* evil

#+BEGIN_SRC emacs-lisp
(use-package evil
  :ensure t
  :init (evil-mode 1)
  :config 
    (progn
      ;; (eval-after-load 'helm-gtags
      ;;    '(progn
      ;;       (define-key evil-motion-state-map "C-]" 'helm-gtags-find-tag-from-here)))
      (eval-after-load 'ggtags
        '(progn
           (evil-make-overriding-map ggtags-mode-map 'normal)
           ;; force update evil keymaps after ggtags-mode loaded
           (add-hook 'ggtags-mode-hook #'evil-normalize-keymaps)))
      (setq evil-want-visual-char-semi-exclusive t)))
#+end_src

为ggtags修改默认的键绑定，可以用 M-.
https://blog.csdn.net/Levi_Huang/article/details/84288493

[2019-01-01 周二 00:08:18] helm-gtags不能在statusbar上显示tag的值，这点不如ggtags好用。先用ggtags吧。

* helm
[2014-09-16 09:27:15]

;; (require 'helm-config)

#+BEGIN_SRC emacs-lisp
(use-package helm
  :defer t
  :ensure t)

(use-package helm-config)
(helm-mode 1)
;; (global-set-key (kbd "C-c h") 'helm-mini)
(global-set-key (kbd "C-c m") 'helm-mini)
(global-set-key (kbd "C-c n") 'helm-mini)
(global-set-key (kbd "M-x") 'helm-M-x)
;; (global-set-key (kbd "C-c a") 'helm-apropos)
(global-set-key (kbd "C-x C-f") 'helm-find-files)

(define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to run persistent action
(define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB works in terminal
(define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z

;setq helm-idle-delay 0.0 ; update fast sources immediately (doesn't).
;          helm-input-idle-delay 0.01  ; this actually updates things
;                                      ; reeeelatively quickly.
(setq helm-quick-update t
      helm-M-x-requires-pattern nil ; 在M-x时默认就不显示多余的pattern了，看着烦
      helm-ff-skip-boring-files t)
#+END_SRC

** Search buffers by major-mode

+ multi buffer search
  1. *C-c h* 调出helm-mini buffer
  1. 在pattern: 中 输入 *org 选择buffer中的file，可以匹配多个文件
  1. *Esc m* 或者 *M-SPC* mark刚才匹配的files，会高亮
  1. 按 *C-s* search file content
  1. *C-j* 打开buffer并跳到选择的行
  1. *enter* 打开文件

+ M-SPC/Esc-SPC/C-@ :: 用 *M-SPC* 最方便了，mark当前的buffer，如果已经mark了会取消，先C-n/C-p移动到要取消的file

+ M-u :: 取消全部mark的buffer
+ M-a :: mark全部的buffer
     
[2014-09-16 18:24:22] multi search也可以这样，如在所有buffer中org-mode的buffer，然后找 *org @string_to_find 按 *C-s* 就ok了。

+ C-n/C-p/up/down :: 在helm的选项中上下移动
+ left/right :: 在source间移动， *C-o* 移动到下一个source，source就是group分类，如buffer，最近访问的buffer，创建buffer。
+ M-p/M-n :: 命令历史
             
+ mini buffer
  + M-S-d :: kill buffer and quit，就是 *M-D* 。
  + C-c d :: kill buffer without quitting
             
[2014-09-17 15:06:59] 为什么用了heml以后连dired+的 *R* rename file都变成helm的了？

[2014-10-13 周一 17:51:09] helm mini中，选择buffer后，按 =F9= 可以查找，这个更加方便。

** grep

=helm-resume= 恢复上次的command

*** Grep from helm-find-files

From helm-find-files (helm-command-prefix-key C-x C-f) Open the action
menu with tab and choose grep. A prefix arg will launch recursive
grep.

NOTE:You can now launch grep with (C-u) M-g s without switching to the
action pannel.

*** Grep thing at point

Before lauching helm, put your cursor on the start of symbol or sexp
you will want to grep. Then launch helm-do-grep or helm-find-files,
and when in the grep prompt hit C-w as many time as needed.

光标在一个word前面，然后 =helm-do-grep= ，选择grep的目录和文件 ，就可以grep这个word，按 =C-w=
可以跟着grep这个word后面的word。

*** Grep persistent action

As always, C-z will bring you in the buffer corresponding to the file
you are grepping. Well nothing new, but using C-u C-z will record this
place in the mark-ring. So if you want to come back later to these
places, there is no need to grep again, you will find all these places
in the mark-ring. Accessing the mark-ring in Emacs is really
inconvenient, fortunately, you will find in helm-config
helm-all-mark-ring which is a mark-ring browser
(helm-command-prefix-key C-c SPACE). helm-all-mark-ring is in helm
menu also, in the tool section.

TIP: Bind helm-all-mark-ring to C-c SPACE.

在org mode下，无效。
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c <SPC>") 'helm-all-mark-rings)
#+END_SRC

NOTE: helm-all-mark-ring handle global-mark-ring also.

* helm-swoop
[2014-11-21 周五 09:26:34]

#+BEGIN_SRC emacs-lisp
(use-package helm-swoop
  :ensure t
  :defer t
  :bind (("M-i" . helm-swoop)
        ("M-I" . helm-swoop-back-to-last-point)
        ( "C-c M-i" . helm-multi-swoop)
        ( "C-x M-i" . helm-multi-swoop-all)))
#+END_SRC

* helm-gtags [2018-12-31 周一 23:31:48]

#+BEGIN_SRC emacs-lisp
(use-package helm-gtags
  :ensure t
  :defer t
  :init
    (setq helm-gtags-ignore-case t
          helm-gtags-auto-update t
          helm-gtags-use-input-at-cursor t
          helm-gtags-pulse-at-cursor t
          helm-gtags-prefix-key "\C-cg"
          helm-gtags-suggested-key-mapping t))

(defun set-helm-gtags-keybindings ()
  (define-key helm-gtags-mode-map (kbd "C-c g a") 'helm-gtags-tags-in-this-function)
  (define-key helm-gtags-mode-map (kbd "C-c g s") 'helm-gtags-select)
  (define-key helm-gtags-mode-map (kbd "M-."    ) 'helm-gtags-dwim)
  (define-key helm-gtags-mode-map (kbd "M-,"    ) 'helm-gtags-pop-stack)
  (define-key helm-gtags-mode-map (kbd "C-c g p") 'helm-gtags-previous-history)
  (define-key helm-gtags-mode-map (kbd "C-c g n") 'helm-gtags-next-history))

(add-hook 'helm-gtags-mode-hook 'set-helm-gtags-keybindings)

#+END_SRC

* helm-ag [2019-01-01 周二 00:15:53]
https://emacs-china.org/t/emacs-helm-ag/6764/7 如何定位并解决Emacs helm-ag的中文搜索问题
* ggtags [2019-01-01 周二 00:32:00]

| key     | function              | 说明                       |
|---------+-----------------------+----------------------------|
| M-.     | ggtags-find-tag-dwim  | C-] 在evil-mode中 无法bind |
| M-,/C-T | xref-pop-marker-stack | C-T bind的是 pop-tag-mark  |
| M-]     | ggtags-find-reference | 查询调用了tag的reference   |

#+BEGIN_SRC emacs-lisp
(use-package ggtags
  :defer t
  :ensure t)

(add-hook 'c-mode-common-hook
  (lambda ()
    (when (derived-mode-p 'c-mode 'c++-mode 'java-mode 'asm-mode)
      (progn
        (linum-mode 1)
        (ggtags-mode 1)))))
#+END_SRC

* window-number

different from window-numbering.el
直接按 *M-num* 就ok，完了，用了这个都忘记怎么切窗口了， ^_^ *C-x o*, *C-x 1*

#+BEGIN_SRC emacs-lisp
(use-package window-numbering
  :ensure t
  :defer t
  :init (window-numbering-mode 1))
#+END_SRC

* undotree

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :defer t
  :config
    (progn
      (global-undo-tree-mode)
      (setq undo-tree-visualizer-timestamps t)
      (setq undo-tree-visualizer-diff t)))

(defalias 'redo 'undo-tree-redo)
;;(global-set-key (kbd "C-z") 'undo) ; 【Ctrl+z】
;;(global-set-key (kbd "C-S-z") 'redo) ; 【Ctrl+Shift+z】;  Mac style
;;(global-set-key (kbd "C-y") 'redo) ; 【Ctrl+y】; Microsoft Windows style
(global-set-key (kbd "C-r") 'redo) ; 【Ctrl+r】; VIM style
#+END_SRC

* python

pdb setup, note the python version
#+BEGIN_SRC lisp
;; (setq pdb-path 'c:/Python/Python36/Lib/pdb.py
;;        gud-pdb-command-name (symbol-name pdb-path))
;;  (defadvice pdb (before gud-query-cmdline activate)
;;    "Provide a better default command line when called interactively."
;;    (interactive
;;     (list (gud-query-cmdline pdb-path
;;                  (file-name-nondirectory buffer-file-name)))))
#+end_src

[2018-11-29 周四 16:15:34]
#+BEGIN_SRC emacs-lisp
(setq python-shell-interpreter "ipython"
;; (setq python-shell-interpreter "python"
      python-shell-interpreter-args "-i --simple-prompt")

(use-package python-mode
  :mode (("SConstruct\\'" . python-mode)
         ("SConscript\\'" . python-mode)
         ("\\.py\\'"      . python-mode))
  :defer t
  ;; [2018-12-01 周六 22:13:10] 为什么execl-test.py不能显示中文doc，而且不停报错?
  :init (elpy-enable)
  :config
  (use-package elpy
    :ensure t
    :defer t
    :init
    (progn
      ;;(setq elpy-rpc-python-command "python3")
      (elpy-use-ipython)
      ;; (add-hook 'elpy-mode-hook (lambda () (elpy-shell-toggle-dedicated-shell 1)))
      ;; use flycheck not flymake with elpy
      (when (require 'flycheck nil t)
        (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
        (add-hook 'elpy-mode-hook 'flycheck-mode)))))

;; (elpy-enable)
#+END_SRC

* basic setting - 可以推迟启动的
** 去掉启动欢迎界面

#+begin_src emacs-lisp
(setq inhibit-startup-message t) 
#+end_src

** 不要总是没完没了的问yes or no

#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** 不显示工具栏和滚动条
[2014-11-18 周二 17:39:59] 把scrollbar也去掉了

#+begin_src emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)

(if (eq window-system 'w32)
  (scroll-bar-mode -1))
#+end_src

** 光标靠近鼠标的时候，让鼠标自动让开，别挡住视线

#+begin_src emacs-lisp
(mouse-avoidance-mode 'animate)
#+end_src

** Frame title

#+begin_src emacs-lisp
(setq frame-title-format "Albert@%f")
#+end_src

;;(setq frame-title-format "Albert@%b")
** minibuffer
[2014-09-12 09:24:17]

It often displays so much information, even temporarily, that it is nice to give
it some room to breath.

#+BEGIN_SRC emacs-lisp
(setq resize-mini-windows t)
(setq max-mini-window-height 0.33)
#+END_SRC

** Backups
[2014-09-12 09:32:53]

This is one of the things people usually want to change right away. By default, 
Emacs saves backup files in the current directory. These are the files ending in ~ that are cluttering up your directory lists. 
The following code stashes them all in ~/.emacs.d/backups, where I can find them with C-x C-f (find-file) if I really need to.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backup")))

;; 自动存盘
(setq auto-save-mode t) 
#+END_SRC

Disk space is cheap. Save lots.
#+BEGIN_SRC emacs-lisp
(setq delete-old-versions -1)
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
#+END_SRC

** Color theme

emacs24自带的最喜欢的theme。

[2017-04-30 周日 23:55:59] 试了一下solarized，在light mode下不好看，太晃眼，helm不知道选中了哪个，dark mode也一样，org mode中代码的高亮没有了。deeper-blue更好。
#+BEGIN_SRC emacs-lisp
(load-theme 'deeper-blue t)
#+END_SRC

;; (load-theme 'solarized t)
;; (load-theme 'tango-dark t)
;; (load-theme 'manoj-dark t)

** Diredplus

[2014-09-11 10:47:57] 昨天刚开始用的，五颜六色的比较好看。

[2014-11-18 周二 10:54:56] 为什么在24.4上就不显示时间戳和权限了呢？

set =diredp-hide-details-initially-flag= to nil in 24.4 to display details, set
before dired+ loaded

也可以按 =(= 打开或关闭detail显示。

#+BEGIN_SRC emacs-lisp
(setq diredp-hide-details-initially-flag nil)
(use-package dired+
  :defer t)
#+END_SRC

** 多行代码的注释/反注释

其实可以考虑vim的 =<leader> + \= 进行注释的。
#+BEGIN_SRC emacs-lisp
(global-set-key [?\C-c ?\C-/] 'comment-or-uncomment-region)

(defun my-comment-or-uncomment-region (beg end &optional arg)  
  (interactive (if (use-region-p)  
                   (list (region-beginning) (region-end) nil)  
                   (list (line-beginning-position)  
                       (line-beginning-position 2))))  
  (comment-or-uncomment-region beg end arg)  
)  
(global-set-key [remap comment-or-uncomment-region] 'my-comment-or-uncomment-region)  
#+END_SRC

** ibuffer

使用emacs时经常需要管理多个buffer， /C-x C-b/ 的默认界面太过简陋。emacs事实上已
经提供了更好的buffer管理界面ibuffer，在配置文件中选用即可。

启用ibuffer支持，增强 *buffer*, 用了helm，ibuffer可以退休了。  
#+BEGIN_SRC emacs-lisp
(use-package ibuffer
  :defer t
  :config (global-set-key (kbd "C-x C-b") 'ibuffer))
#+END_SRC

** 字体放大缩小

from sacha chua
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-=") 'text-scale-increase)
(global-set-key (kbd "C--") 'text-scale-decrease)
#+END_SRC

** 显示匹配的括号

#+BEGIN_SRC emacs-lisp
(show-paren-mode t)
#+END_SRC

** 显示行、列号

在status bar显示，不在buffer的左侧显示每行的行号，否则真的会很慢。

列号是从0开始的。
#+BEGIN_SRC emacs-lisp
(column-number-mode t)
#+END_SRC

[2014-03-17 17:54:25] 不显示行号，否则速度会非常慢

#+BEGIN_SRC lisp
;;另外一个显示行号的插件，个人更喜欢的风格
;(require 'linum)
;(global-linum-mode t)
#+END_SRC

** F5插入当前时间
insert current time，要加上(interactive)啊，为什么呢？

#+BEGIN_EXAMPLE
M-: (insert (format-time-string "[%Y-%m-%d %a %T]"))
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
(global-set-key [(f5)] '(lambda () (interactive) 
(insert (format-time-string "[%Y-%m-%d %a %T]"))
))
#+END_SRC

** Reading

https://github.com/xahlee/xah_emacs_init/blob/master/xah_emacs_font.el From Xah Lee:

#+BEGIN_SRC emacs-lisp
(defun xah-toggle-margin-right ()
  "Toggle the right margin between `fill-column' or window width.
This command is convenient when reading novel, documentation."
  (interactive)
  (if (eq (cdr (window-margins)) nil)
      (set-window-margins nil 0 (- (window-body-width) fill-column))
    (set-window-margins nil 0 0)))
#+END_SRC

** Make window splitting more useful

I added these snippets to my .emacs so that when I split the screen with C-x 2 or C-x 3, 
it opens the previous buffer instead of giving me two panes with the same buffer:

Copied from http://www.reddit.com/r/emacs/comments/25v0eo/you_emacs_tips_and_tricks/chldury

#+BEGIN_SRC emacs-lisp
(defun vsplit-last-buffer ()
  (interactive)
  (split-window-vertically)
  (other-window 1 nil)
  (switch-to-next-buffer)
  )
(defun hsplit-last-buffer ()
  (interactive)
   (split-window-horizontally)
  (other-window 1 nil)
  (switch-to-next-buffer)
  )

(global-set-key (kbd "C-x 3") 'vsplit-last-buffer)
(global-set-key (kbd "C-x 2") 'hsplit-last-buffer)
#+END_SRC

** 图片支持
[2014-09-18 08:49:12]

=M-x list-dynamics-libraries= 找到对应的dll的name。

可以运行下面几行代码检查一下是否已经支持了图片。

#+BEGIN_SRC lisp
(image-type-available-p 'gif)

(image-type-available-p 'jpeg)

(image-type-available-p 'tiff)

(image-type-available-p 'xbm)

(image-type-available-p 'xpm)

(image-type-available-p 'png)
#+END_SRC

这几个函数复制到Lisp模式的buffer，然后在每一行行尾按 *C-j* ，就可以看到每个函数运行的结果，返回 *t* 证明已经可以支持图片了。

win的emacs不能显示图片是因为编译后默认没有带几个dll文件。把dll copy到emacs安装目录的bin目录下，就可以显示图片了。

*** emacs 24.4
+ png
  [2014-11-18 周二 15:48:21] emacs 24.4需要libpng16-16.dll or libpng16.dll 和 zlib1.dll，都在libpng的压缩包里面
  可以从 http://sourceforge.net/projects/ezwinports/files/ 下载

*** emacs 24.3
+ png :: libpng14.dll

#+BEGIN_EXAMPLE
jpeg62.dll
libgcrypt-11.dll
libgnutls-26.dll
libpng14-14.dll
libtasn1-3.dll
libtiff3.dll
libungif4.dll
libXpm.dll
xpm4.dll
zlib1.dll
#+END_EXAMPLE

可以从 https://github.com/winterTTr/emacs-of-winterTTr/tree/master/.emacs.d/extra-bin/dlls 下载

** 输入特殊字符
[2014-09-29 周一 17:20:40]

+  :: C-q C-a

+ C-q X :: 是一个通用的输入特殊字符的解决办法，X 表示一个特殊字符， 在几乎所有的模式下，输入 =C-q= 然后是一个就可以输入这个特殊字符。
一般来说、所有的特殊的字符都和某一个特定的函数绑定在一起 了，例如 C-a , ASCII 1 , 表示 beginning-of-line 。 换行的字符就是 C-j ， ASCII 10。
除了输入 C-j ，还可以输入回车字符的 ASCII 的 8 进制数， 例如 C-q 1 2 。 因为 C-j 对应的 ACSII 是 10, 012 八进制 ， 0xA 十六进制。
#+BEGIN_SRC lisp
(setq read-quoted-char-radix 10)
;or
(setq read-quoted-char-radix 16)
#+END_SRC

可以改为把八进制改为十进制或者十六进制。或者用命令
#+BEGIN_EXAMPLE
M-x set-variable <RET> read-quoted-char-radix <RET>10 
#+END_EXAMPLE

** save the cursor position for every file you opened

Turn on save place so that when opening a file, the cursor will be at the last position.
#+BEGIN_SRC emacs-lisp
;; For GNU Emacs 24.5 and older versions
;; (require 'saveplace)
;; (setq save-place-file (concat user-emacs-directory "saveplace.el") ) ; use standard emacs dir
;; (setq-default save-place t)

;; For GNU Emacs 25.1 and newer versions
(setq-default save-place t)
(use-package saveplace
  :ensure t
  :init (save-place-mode 1))
#+END_SRC

** mode-line
[2014-11-21 周五 10:35:59]

smart-mode-line和powerline都不好用，速度太慢。
#+BEGIN_SRC lisp
;; (use-package smart-mode-line
;;   :disabled t
;;   :init
;;   (progn
;;   (setq-default
;;    mode-line-format 
;;    '("%e"
;;      mode-line-front-space
;;      mode-line-mule-info
;;      mode-line-client
;;      mode-line-modified
;;      mode-line-remote
;;      mode-line-frame-identification
;;      mode-line-buffer-identification
;;      "   "
;;      mode-line-position
;;      (vc-mode vc-mode)
;;      "  "
;;      mode-line-modes
;;      mode-line-misc-info
;;      mode-line-end-spaces))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; 显示日期时间
(setq display-time-day-and-date t)

;(setq display-time-24hr-format t)
;(setq display-time-use-mail-icon t)
(setq display-time-interval 10)
(setq display-time-format "%Y-%m-%d %a %H:%M")
(setq display-time-default-load-average nil)
(display-time)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package diminish
  :defer t)

;(eval-after-load "yasnippet" '(diminish 'yas-minor-mode))
(eval-after-load "undo-tree" '(diminish 'undo-tree-mode))
;(eval-after-load "guide-key" '(diminish 'guide-key-mode))
;(eval-after-load "smartparens" '(diminish 'smartparens-mode))
;(eval-after-load "guide-key" '(diminish 'guide-key-mode))
(eval-after-load "eldoc" '(diminish 'eldoc-mode))
(eval-after-load "org-indent" '(diminish 'org-indent-mode))
(eval-after-load "highlight-parentheses" '(diminish 'highlight-parentheses-mode))

(diminish 'visual-line-mode)
#+END_SRC

#+BEGIN_SRC lisp
;; (use-package powerline
;;   :disabled t
;;   :ensure t
;;   :config 
;;     (progn
;;        (powerline-center-evil-theme)
;;        (setq powerline-arrow-shape 'arrow)
;;        (custom-set-faces  
;;          '(mode-line ((t (:foreground "white" :background "#8080ff" :box nil))))  
;;          ;; '(mode-line-inactive ((t (:foreground "white" :background "#ff8080" :box nil))))  
;;          )))
;;       ;; (powerline-default-theme)))
;;       ;; (powerline-center-evil-theme)))
#+END_SRC

* scheme [2017-03-02 周四 21:27:47]

;; (require 'cmuscheme)
#+BEGIN_SRC emacs-lisp
  (use-package cmuscheme
    :defer t)
  (setq scheme-program-name "racket")         ;; 如果用 Petite 就改成 "petite"
  ;; (setq scheme-program-name "scheme")         ;; 如果用 Petite 就改成 "petite"

  ;; bypass the interactive question and start the default interpreter
  (defun scheme-proc ()
    "Return the current Scheme process, starting one if necessary."
    (unless (and scheme-buffer
		 (get-buffer scheme-buffer)
		 (comint-check-proc scheme-buffer))
      (save-window-excursion
	(run-scheme scheme-program-name)))
    (or (scheme-get-process)
	(error "No current process. See variable `scheme-buffer'")))

  (defun scheme-split-window ()
    (cond
     ((= 1 (count-windows))
      (delete-other-windows)
      ;; (split-window-vertically (floor (* 0.68 (window-height))))
      (split-window-horizontally (floor (* 0.60 (window-width))))
      (other-window 1)
      (switch-to-buffer "*scheme*")
      (other-window 1))
     ((not (cl-find "*scheme*"
		 (mapcar (lambda (w) (buffer-name (window-buffer w)))
			 (window-list))
		 :test 'equal))
      (other-window 1)
      (switch-to-buffer "*scheme*")
      (other-window -1))))

  (defun scheme-send-last-sexp-split-window ()
    (interactive)
    (scheme-split-window)
    (scheme-send-last-sexp))

  (defun scheme-send-definition-split-window ()
    (interactive)
    (scheme-split-window)
    (scheme-send-definition))

  (add-hook 'scheme-mode-hook
    (lambda ()
      (paredit-mode 1)
      (evil-paredit-mode 1)
      (define-key scheme-mode-map (kbd "<f6>") 'scheme-send-last-sexp-split-window)
      (define-key scheme-mode-map (kbd "<f7>") 'scheme-send-definition-split-window)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; [2017-04-09 周日 00:20:25]
(use-package paren-face
  :defer t
  :ensure t
  :init (global-paren-face-mode 1)
)
#+END_SRC
* web-mode [2018-02-08 周四 17:03:42]

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :defer t)
#+END_SRC
* markdown-mode

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :defer t
  :commands (markdown-mode gfm-mode)
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init (setq markdown-command "multimarkdown"))
#+END_SRC
  
* xah-find [2018-09-29 周六 22:09:48]
http://ergoemacs.org/emacs/elisp-xah-find-text.html

1. evil mode下按tab和enter都不能跳转到文件对应的地方，只能用鼠标，除非是emacs mode下。
2. 不知道是怎么找的扩展吗，如果打开一个 *.te的文件，默认扩展名就是 *.te，改改?

#+BEGIN_SRC emacs-lisp
(use-package xah-find
  :ensure t
  :defer t)
#+END_SRC

* emacs-lisp
[2014-09-27 01:58:44]

lisp语言入门，写得很不错，找不到原出处了 http://www.cnblogs.com/suiqirui19872005/archive/2007/12/05/984517.html

emacs自带的帮助也不错，可以了解emacs lisp的特点，和common lisp的区别慢慢体会。

** 括号高亮
http://www.emacswiki.org/emacs/HighlightParentheses

http://ergoemacs.org/emacs/emacs_editing_lisp.html

#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook
          '(lambda ()
             (highlight-parentheses-mode)))

(define-globalized-minor-mode global-highlight-parentheses-mode
  highlight-parentheses-mode
  (lambda ()
    (highlight-parentheses-mode t)))
(global-highlight-parentheses-mode t)
#+END_SRC

** eldoc-mode
http://sachachua.com/blog/2014/06/read-lisp-tweak-emacs-beginner-24-understand-emacs-lisp-code/

turns on eldoc-mode, which displays the argument list for the current function. 
You can move your cursor around to see argument lists for other functions.
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
#+END_SRC

* magit
[2014-09-11 10:22:26] disable emacs自带的vc，用 *process monitor* 看，vc每次打开都会把支持的版本管理都查一遍，会比较慢。
但是去掉了以后，magit没法在status bar上显示文件在哪个branch上了。哎。

process monitor在用了vpn后会导致机器hang。

把vc disable后会快不少，还是去了吧。

#+BEGIN_SRC lisp
;; (custom-set-variables
;; '(vc-handled-backends (quote (Git))))

;; disable default vc
;(setq vc-handled-backends nil)
#+end_src

[2014-09-11 14:25:06] 即使更新到了0908的magit，仍然发现有多次调用git.exe的情况， *magit-status* 还是慢
把git的path设置到最前面，貌似速度也没快多少，最多0.001s吧。

;;(if (eq system-type 'windows-nt)
;;    (progn
;;      (setq exec-path (add-to-list 'exec-path "C:/Program Files/Git/bin"))
;;      (setenv "PATH" (concat "C:\\Program Files\\Git\\bin;" (getenv "PATH")))))

#+BEGIN_SRC emacs-lisp
(use-package magit
  :defer t
  :config
    (progn
      (setq magit-last-seen-setup-instructions "1.4.0")))
#+end_src

* tramp on windows [2018-12-28 周五 11:14:58]

+ new session
  /plink:user@host:/path/to/your/file/on/server

+ saved session
  /plinkx:sessname:/path/to/your/file/on/server
  
+ 不需要设置 tramp-shell-prompt-pattern 和 tramp-password-end-of-line 。
+ plink要在PATH里有。

#+BEGIN_SRC emacs-lisp
(use-package tramp
  :defer t
  :config
    (progn
      (setq exec-path (cons "E:/tools/putty" exec-path))
      ;; (setq tramp-password-end-of-line "\r\n")
      ;; (setq tramp-shell-prompt-pattern "^[ $]# +")
      (setq tramp-default-method "plink")))
#+END_SRC
* c-mode coding style [2019-01-05 周六 11:20:13]

emacs使用google-c-style
google c++编码规范很全面，现在已经逐渐习惯了这种编码规范，突然想到或许emacs中有合适的el支持这种规范，到网上一找，果然有。

http://google-styleguide.googlecode.com/svn/trunk/google-c-style.el

elpa中安装就可以了。

下载下来，放在emacs.d目录下，然后在.emacs配置文件中添加几行：

(add-to-list 'load-path (expand-file-name "~/.emacs.d"))
(require 'google-c-style)
(add-hook 'c-mode-common-hook 'google-set-c-style)
(add-hook 'c-mode-common-hook 'google-make-newline-indent)

(add-hook 'c-mode-common-hook
          (lambda ()
            (setq c-default-style "k&r" c-basic-offset 4)
            (c-set-offset 'substatement-open 0)))

#+BEGIN_SRC emacs-lisp

(setq c-default-style "linux")
(setq c-basic-offset 4)

(setq default-tab-width 4)
(setq-default indent-tabs-mode nil)

;; (setq tab-width 4)
;; (setq tab-stop-list ())
#+END_SRC
* graphviz [2019-01-08 周二 18:13:47]

主要思想是解析 =buffer= 中选中的文本，通过正则表达式来匹配，从中找到 struct name 以及其中的各个 fields， 最后根据 =dot= 语法将其组成一个 =subgraph= 。其实应该有更好的方法（比如通过 CEDET 的 Semantic 解析结果来做），但对 CEDET 的代码实在不熟，所以现在就只能这样了。
#+BEGIN_SRC emacs-lisp
;; Function used to add fields of struct into a dot file (for Graphviz).
(defconst yyc/dot-head "subgraph cluster_%s {
    node [shape=record fontsize=12 fontname=Courier style=filled];
    color = lightgray;
    style=filled;
    label = \"Struct %s\";
    edge[color=\"#2e3436\"];"
  "Header part of dot file.")

(defconst yyc/dot-tail "
}"
  "Tail part of dot")

(defconst yyc/dot-node-head
  "
        node_%s[shape=record label=\"<f0>*** STRUCT %s ***|\\"
  "Format of node.")

(defconst yyc/dot-node-tail "
\"];"
  "Format of node.")
 
(defconst r_attr_str "[ \t]+\\(.*+\\)[ \t]+\\(.*\\)?;"
  "Regular expression for matching struct fields.")
 
;; (defconst r_name (caar (semantic-parse-region start end))
(defconst r_name "\\_<\\(typedef[ \t]+\\)?struct[ \t]+\\(.*\\)?[ \t]*{"
  "Regular expression for mating struct name")
 
(defconst attr_str "
<f%d>%s %s\\l|\\" "nil")
 
(defun yyc/datastruct-to-dot (start end)
  "generate c++ function definition and insert it into `buffer'"
  (interactive "rp")
  (setq var-defination (buffer-substring-no-properties start end))
  (let* ((tmp_str "")
         (var-name "")
         (var-type "")
         (counter 0)
         (struct-name "")
         (header-str ""))
    (defun iter (pos)
      (setq counter (+ counter 1))
      (message (format "Counter: %d, pos: %d"
                       counter pos))
      (if (string-match r_name var-defination pos)
          (progn
            (message "A")
            (setq struct-name
                  (match-string 2 var-defination))
            ;; (setq struct-name (caar (semantic-parse-region start end)))
            (setq header-str
                  (format yyc/dot-head struct-name struct-name))
            (setq tmp_str
                  (format yyc/dot-node-head struct-name struct-name))
            (iter (match-end 0)))
        (if (string-match r_attr_str var-defination pos)
            (progn
              (message "B")
              (setq var-type
                    (match-string 1 var-defination))
              (setq var-name
                    (match-string 2 var-defination))
              (setq tmp_str
                    (concat tmp_str
                            (format attr_str counter var-type var-name)))
              (iter (match-end 0)))
          nil)))
    (save-excursion
      (iter 0)
      (set-buffer (get-buffer-create "tmp.dot"))
      ;;(graphviz-dot-mode)
      (setq pos (point-max))
      (insert  header-str tmp_str )
      (goto-char (point-max))
      (delete-char -1)
      (insert "<f999>\\"yyc/dot-node-tail yyc/dot-tail)
      )
    (if (one-window-p)
        (split-window-vertically))
    (switch-to-buffer-other-window "tmp.dot")
    (goto-char (point-min))
    )
  (message "Finished, please see *tmp.dot* buffer.")
  )
#+END_SRC

使用方法
用起来很简单：找到一个 C 代码，标记整个 struct 定义，然后M-x 输入： yyc/datastruct-to-dot 即可。命令执行完毕后，会打开一个新的 tmp.dot buffer，其中包含了用于绘制该 struct 的代码。前面也提到了，这生成的仅仅是个 subgraph，需要将这个 subgraph 添加到真正的 graph 下，才能生成图像。我通过 autoinsert 来自动创建用于放置 subgraph 的 graph 。

** autoinsert配置
autoinsert 是 Emacs 自带的功能，稍加配置即可使用：

#+BEGIN_SRC emacs-lisp
;; ************** Autoinsert templates *****************
(use-package autoinsert
  :defer t)

(setq auto-insert-mode t)  ;;; Adds hook to find-files-hook
(setq auto-insert-directory "~/.emacs.d/templates/auto-insert/")
(setq auto-insert 'other)
(setq auto-insert-query nil)
 
;; auto-insert stuff
(add-hook 'find-file-hooks 'auto-insert)
(setq auto-insert-alist
      '(
        ("\\.cpp$" . ["insert.cpp" auto-update-c-source-file])
        ("\\.h$"   . ["header.h" auto-update-header-file])
        ("\\.c$" . ["insert.c" auto-update-c-source-file])
        ("\\.org$" . ["insert.org" auto-update-defaults])
        ("\\.sh$" . ["insert.sh" auto-update-defaults])
        ("\\.lisp$" . ["insert.lisp" auto-update-defaults])
        ("\\.el$" . ["insert.el" auto-update-defaults])
        ("\\.dot$" . ["insert.dot" auto-update-defaults])
        ("\\.erl$" . ["insert.err" auto-update-defaults])
        ("\\.py$" . ["insert.py" auto-update-defaults])
        ("\\.tex$" . ["insert.tex" auto-update-defaults])
        ("\\.html$" . ["insert.html" auto-update-defaults])
        ("\\.devhelp2$" . ["insert.devhelp2" auto-update-defaults])
        ("\\.ebuild$" . ["insert.ebuild" auto-update-defaults])
        ("\\.sh$" . ["insert.sh" auto-update-defaults])
        ("Doxyfile$" . ["insert.doxyfile" auto-update-defaults])
        ))
 
;; function replaces the string '@@@' by the current file
;; name. You could use a similar approach to insert name and date into
;; your file.
(defun auto-update-header-file ()
  (save-excursion
    (while (search-forward "@@@" nil t)
      (save-restriction
        (narrow-to-region (match-beginning 0) (match-end 0))
        (replace-match (upcase (file-name-nondirectory buffer-file-name)))
        (subst-char-in-region (point-min) (point-max) ?. ?_)
        ))))
 
(defun insert-today ()
  "Insert today's date into buffer"
  (interactive)
  (insert (format-time-string "%m-%e-%Y" (current-time))))
 
(defun auto-update-c-source-file ()
  (save-excursion
    ;; Replace HHHH with file name sans suffix
    (while (search-forward "HHHH" nil t)
      (save-restriction
        (narrow-to-region (match-beginning 0) (match-end 0))
        (replace-match (concat (file-name-sans-extension (file-name-nondirectory buffer-file-name)) ".h") t)
        )))

  (save-excursion
    ;; Replace @@@ with file name
    (while (search-forward "@@@" nil t)
      (save-restriction
        (narrow-to-region (match-beginning 0) (match-end 0))
        (replace-match (file-name-nondirectory buffer-file-name))
        )))
  (save-excursion
    ;; replace DDDD with today's date
    (while (search-forward "DDDD" nil t)
      (save-restriction
        (narrow-to-region (match-beginning 0) (match-end 0))
        (replace-match "")
        (insert-today)
        ))))
 
(defun auto-replace-file-name ()
  (save-excursion
    ;; Replace @@@ with file name
    (while (search-forward "(>>FILE<<)" nil t)
      (save-restriction
        (narrow-to-region (match-beginning 0) (match-end 0))
        (replace-match (file-name-nondirectory buffer-file-name) t)
        ))
    ))
 
(defun auto-update-defaults ()
  (auto-replace-file-name)
  (auto-replace-file-name-no-ext)
  (auto-replace-date-time))
 
(defun auto-replace-file-name-no-ext ()
  (save-excursion
    ;; Replace @@@ with file name
    (while (search-forward "(>>FILE_NO_EXT<<)" nil t)
      (save-restriction
        (narrow-to-region (match-beginning 0) (match-end 0))
        (replace-match (file-name-sans-extension (file-name-nondirectory buffer-file-name)) t)
        ))))
 
(defun auto-replace-date-time ()
  (save-excursion
    (while (search-forward "(>>DATE<<)" nil t)
      (save-restriction
        (narrow-to-region (match-beginning 0) (match-end 0))
        (replace-match "" t)
        (insert-today)
        ))))
#+END_SRC

模板文件存放于 “~/.emacs.d/templates/auto-insert/” 中，其中， insert.dot 的内容如下：

// $Id: (>>FILE<<), (>>DATE<<)
digraph Name {
    node [shape=record fontsize=12 fontname=Courier style=filled];
    edge[color=blue];
    rankdir=LR;

// XXX: place to put subgraph

}

** 用法示例
一个简单的使用示例，有如下步骤：

1: 打开一个 C 文件
 

如内核代码中的 drivers/usb/storage/usb.h

2: 打开一个 dot 文件(/tmp/usb.dot)
 

auto-insert 会自动插入一些文件内容.

3: 选中 struct us_data 的定义，并执行 yyc/datastruct-to-dot。

执行完成后， us_data 的数据填写到了 tmp.dot 中，将该 buffer 中的所有内容 kill 掉，并 yank 到 usb.dot 中 XXX 这一行的下面。此时，保存 sub.dot ， 并按下快捷键 : C-cc ， 然后按下 Enter ， 就会自动编译。然后再按下 C-cp 就可以在另外一个 buffer 中预览它了。

其实到这里，一个 C 语言的 struct 数据结构就已经被画出来了，后面的两个步骤，是为了介绍怎样将多个数据结构联系起来。

4: 添加其他的 subgraph 

我们可以继续添加其他的 subgraph ， 例如 struct usb_ctrlrequest *cr ，以及 struct usb_sg_request， 并全部做为 subgraph 添加到 usb.dot 中。

5: 为 subgraph 建立关联

很简单，通过 “->” 画两条线就可以了。

** semantic [2019-01-08 周二 20:47:56]
https://segmentfault.com/a/1190000004910645?utm_source=tuicool&utm_medium=referral [译] Emacs Lisp 速成

                ;; 这样写不太好看
                 ;; (if (eq function-pointer t)
                 ;;     (setq str (var-str str index type))
                 ;;   (setq str (concat str (format "%s " (semantic-tag-name type)))))))

#+BEGIN_SRC emacs-lisp
(defun albert/datastruct-member (tag)
  "parse tag generated by semantic-parse-region."

  (defun fp-str (str ftag)
    "function pointer args to str. 函数指针参数的处理.如ngx_tcp_module_t里的函数指针"
    (cond
      ((null ftag) "")
      ((cond
         ((semantic-tag-p ftag)
           (let* ((name (semantic-tag-name ftag))
                  (type (semantic-tag-get-attribute ftag :type))
                  (pointer (semantic-tag-get-attribute ftag :pointer)))
             (cond
               ((atom type) (setq str (concat str (format "%s " type))))
               ((semantic-tag-p type) 
                 (setq str (concat str (format "%s " (semantic-tag-name type))))))
 
             (if (numberp pointer)
               (setq str (concat str (make-string pointer ?*))))

             (setq str (concat str (format "%s, " name)))
             ))
         (t (setq str (concat (fp-str str (car ftag)) (fp-str str (cdr ftag)))))
         ))
    ))

  (defun var-str (str index vtag)
    (setq str (format "    <f%d>" index))
    (cond
      ((null vtag) "")
      ((cond
         ((semantic-tag-p vtag)
           (let* ((name (semantic-tag-name vtag))
                  (type (semantic-tag-get-attribute vtag :type))
                  ;;(function-pointer (semantic-tag-get-attribute vtag :function-pointer))
                  (pointer (semantic-tag-get-attribute vtag :pointer)))
             (cond
               ((atom type) (setq str (concat str (format "%s " type))))
               ;; 函数指针要单独处理,如ngx_tcp_module_t里的函数指针
               ((semantic-tag-p type) 
                 (setq str (concat str (format "%s " (semantic-tag-name type))))))
 
             (if (numberp pointer)
               (setq str (concat str (make-string pointer ?*))))

             (if (semantic-tag-get-attribute vtag :function-pointer)
                 (let* ((tmp (fp-str "" (semantic-tag-components vtag)))
                        (args (substring tmp 0 (- (length tmp) 2))))
                       (setq str (format "%s(*%s)(%s) \\l|\\\n" str name args)))
               (concat str (format "%s \\l|\\\n" name)))
             ))
       (t (concat (var-str str (+ index 1) (car vtag)) (var-str str (+ index 1) (cdr vtag))))
         ))
      ))
  (var-str "" 0 tag))
  
(defun albert/datastruct-dot-head (tag)
  "datastruct name to dot head."
  (let ((name (semantic-tag-name tag)))
    (format "subgraph cluster_%s {
  node [shape=record fontsize=12 fontname=Courier style=filled];
  color=lightgray;
  style=filled;
  label = \"Struct %s\";
  edge[color=\"#2e3436\"];
  node_%s [shape=record label=\"\n" name name name)))
  
(defun albert/datastruct-dot-end (str)
  "datastruct to dot end string. 去掉最后一个字段的\l|\n"
  (concat (substring str 0 (- (length str) 3)) "\"];
}\n"))

(defun albert/semantic-lex-buffer (start end)
  "parse c datastruct definition using semantic and insert it into `buffer'"
  (interactive "rp")
  (message "start=%d, end=%d" start end)
  (let* ((tag (car (semantic-parse-region start end)))
         (members (plist-get (semantic-tag-class (semantic-tag-get-attribute tag :typedef)) :members)))
    ;; (message "%s\n" tag)
    ;;(message "%s" (albert/datastruct-dot-head tag))
    ;; (message "%s" (albert/datastruct-member (semantic-tag-components tag)))
    (let* ((body (albert/datastruct-member (semantic-tag-components tag)))
           (dot_str (albert/datastruct-dot-end body)))
      ;;(message "%s" (albert/datastruct-dot-end body))
      (save-excursion
        ;;(iter 0)
        (set-buffer (get-buffer-create "tmp.dot"))
        ;;(graphviz-dot-mode)
        (setq pos (point-max))
        (insert (albert/datastruct-dot-head tag) 
                dot_str)
        (goto-char (point-max))
        (delete-char -1)
      )

      (if (one-window-p)
        (split-window-vertically))

      (switch-to-buffer-other-window "tmp.dot")
      (goto-char (point-min))
    )))

     ;; (plist-get (nthcdr 2 (semantic-tag-get-attribute tag :typedef)) :members))

  ;; (message (semantic-parse-region start end 1)))
  ;; (message (semantic-c-lexer start end 1)))
  ;; (message (semantic-lex-buffer)))
  ;;(semantic-lex start end 1))


#+END_SRC
* winner-mode [2019-01-09 周三 18:04:05]
这个是Emacs自带，打开(winner-mode t)之后，就可以用C-x <left>和C-x <right>来对窗口布局实现undo/redo了。

#+BEGIN_SRC emacs-lisp
;; (use-package winner-mode
;;   :init (winner-mode t))
 
(winner-mode t)
#+END_SRC
* 现在没用的配置
** 反显选中区域

emacs 23以后默认。
#+begin_src lisp
;(transient-mark-mode t) 
#+end_src
** Mode line format
[2014-09-16 18:18:58]

Display a more compact mode line.

#+BEGIN_SRC lisp
;(use-package smart-mode-line
;(defun my-line()
;  :init
;  (progn
;  (setq-default
;   mode-line-format 
;   '("%e"
;     mode-line-front-space
;     mode-line-mule-info
;     mode-line-client
;     mode-line-modified
;     mode-line-remote
;     mode-line-frame-identification
;     mode-line-buffer-identification
;     "   "
;     mode-line-position
;     (vc-mode vc-mode)
;     "  "
;     mode-line-modes
;     mode-line-misc-info
;     mode-line-end-spaces))))
;(my-line)
#+END_SRC
** ido

#+BEGIN_SRC lisp
;(require 'ido)
#+END_SRC

** smex
[2014-09-19 14:44:30] 有helm，不用smex了。

Smex is a M-x enhancement for Emacs. Built on top of IDO, it provides a convenient interface 
to your recently and most frequently used commands. And to all the other commands, too.

Extras: Limit commands to those relevant to the active major mode. Show frequently used commands that have no key bindings.

用了smex后，现在已经把command忘记得差不多了，现在magit的话，就会 *M-x magit* 直接联想了。呵呵。

#+BEGIN_SRC lisp
;(require 'smex)
;
;(global-set-key (kbd "M-x") 'smex)
;(global-set-key (kbd "M-X") 'smex-major-mode-commands)
;; This is your old M-x.
;;(global-set-key (kbd "C-c C-c M-x") 'execute-extended-command)
#+END_SRC
** htmlize

为了让org mode中的代码可以语法高亮，不知道新的org 8.2.7c是不是自带了，那就可以不用这个了。

#+BEGIN_SRC lisp
;(require 'htmlize)
#+END_SRC

** ace-jump [2014-11-20 周四 18:09:04]

#+BEGIN_SRC lisp
;;;
;;; ace jump mode major function
;;; 
;(autoload
;  'ace-jump-mode
;  "ace-jump-mode"
;  "Emacs quick move minor mode"
;  t)
;;; you can select the key you prefer to
;(define-key global-map (kbd "C-c SPC") 'ace-jump-mode)
;
;;; 
;;; enable a more powerful jump back function from ace jump mode
;;;
;(autoload
;  'ace-jump-mode-pop-mark
;  "ace-jump-mode"
;  "Ace jump back:-)"
;  t)
;(eval-after-load "ace-jump-mode"
;  '(ace-jump-mode-enable-mark-sync))
;(define-key global-map (kbd "C-x SPC") 'ace-jump-mode-pop-mark)
;
;;;If you use evil
;(define-key evil-normal-state-map (kbd "SPC") 'ace-jump-mode)
#+END_SRC 

